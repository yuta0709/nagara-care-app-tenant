/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Nagara Care API
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import { customInstance } from './custom-instance';
export interface SignInDto {
  loginId: string;
  password: string;
}

export interface TokenDto {
  /** JWTトークン */
  token: string;
}

export interface UserDto {
  /** ユーザーUID */
  uid: string;
  /** ログインID */
  loginId: string;
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** ユーザー権限 */
  role: string;
  /** テナントUID */
  tenantUid: string;
}

/**
 * ロール
 */
export type UserListItemDtoRole = typeof UserListItemDtoRole[keyof typeof UserListItemDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserListItemDtoRole = {
  GLOBAL_ADMIN: 'GLOBAL_ADMIN',
  TENANT_ADMIN: 'TENANT_ADMIN',
  CAREGIVER: 'CAREGIVER',
} as const;

export interface UserListItemDto {
  /** ユーザーUID */
  uid: string;
  /** ログインID */
  loginId: string;
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** ロール */
  role: UserListItemDtoRole;
  /** 作成日時 */
  createdAt: string;
}

export interface UserListResponseDto {
  /** ユーザー一覧 */
  items: UserListItemDto[];
  /** 総件数 */
  total: number;
}

export interface TenantUserCreateInputDto {
  /** ログインID */
  loginId: string;
  /** パスワード */
  password: string;
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** ユーザー権限 */
  role: string;
}

/**
 * ユーザーロール
 */
export type UserUpdateInputDtoRole = typeof UserUpdateInputDtoRole[keyof typeof UserUpdateInputDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserUpdateInputDtoRole = {
  GLOBAL_ADMIN: 'GLOBAL_ADMIN',
  TENANT_ADMIN: 'TENANT_ADMIN',
  CAREGIVER: 'CAREGIVER',
} as const;

export interface UserUpdateInputDto {
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** ユーザーロール */
  role: UserUpdateInputDtoRole;
}

export interface TenantListItemDto {
  /** テナントUID */
  uid: string;
  /** テナント名 */
  name: string;
  /** 作成日時 */
  createdAt: string;
}

export interface TenantListResponseDto {
  /** テナント一覧 */
  items: TenantListItemDto[];
  /** 総件数 */
  total: number;
}

export interface TenantDto {
  /** テナントUID */
  uid: string;
  /** テナント名 */
  name: string;
  /** 作成日時 */
  createdAt: string;
}

export interface TenantCreateInputDto {
  /** テナント名 */
  name: string;
}

export interface TenantUpdateInputDto {
  /** テナント名 */
  name: string;
}

/**
 * 性別
 */
export type ResidentDtoGender = typeof ResidentDtoGender[keyof typeof ResidentDtoGender];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResidentDtoGender = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
} as const;

export interface ResidentDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** 生年月日 */
  dateOfBirth: string;
  /** 性別 */
  gender: ResidentDtoGender;
  /** 入所日 */
  admissionDate: string;
  /** 作成日時 */
  createdAt: string;
}

export interface ResidentListResponseDto {
  items: ResidentDto[];
  /** 総件数 */
  total: number;
}

/**
 * 性別
 */
export type ResidentCreateInputDtoGender = typeof ResidentCreateInputDtoGender[keyof typeof ResidentCreateInputDtoGender];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResidentCreateInputDtoGender = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
} as const;

export interface ResidentCreateInputDto {
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** 生年月日 */
  dateOfBirth: string;
  /** 性別 */
  gender: ResidentCreateInputDtoGender;
  /** 入所日 */
  admissionDate: string;
}

/**
 * 性別
 */
export type ResidentUpdateInputDtoGender = typeof ResidentUpdateInputDtoGender[keyof typeof ResidentUpdateInputDtoGender];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResidentUpdateInputDtoGender = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
} as const;

export interface ResidentUpdateInputDto {
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** 生年月日 */
  dateOfBirth: string;
  /** 性別 */
  gender: ResidentUpdateInputDtoGender;
  /** 入所日 */
  admissionDate: string;
}

/**
 * 食事の時間帯
 */
export type FoodRecordDtoMealTime = typeof FoodRecordDtoMealTime[keyof typeof FoodRecordDtoMealTime];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordDtoMealTime = {
  BREAKFAST: 'BREAKFAST',
  LUNCH: 'LUNCH',
  DINNER: 'DINNER',
} as const;

/**
 * 飲み物の種類
 */
export type FoodRecordDtoBeverageType = typeof FoodRecordDtoBeverageType[keyof typeof FoodRecordDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface FoodRecordDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 介護者UID */
  caregiverUid: string;
  /** 利用者UID */
  residentUid: string;
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes: string;
  /** 食事の時間帯 */
  mealTime: FoodRecordDtoMealTime;
  /** 主食の摂取率（%） */
  mainCoursePercentage: number;
  /** 副食の摂取率（%） */
  sideDishPercentage: number;
  /** 汁物の摂取率（%） */
  soupPercentage: number;
  /** 飲み物の種類 */
  beverageType: FoodRecordDtoBeverageType;
  /** 飲み物の摂取量（ml） */
  beverageVolume: number;
}

export interface FoodRecordListResponseDto {
  items: FoodRecordDto[];
  /** 総件数 */
  total: number;
}

/**
 * 食事の時間帯
 */
export type FoodRecordCreateInputDtoMealTime = typeof FoodRecordCreateInputDtoMealTime[keyof typeof FoodRecordCreateInputDtoMealTime];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordCreateInputDtoMealTime = {
  BREAKFAST: 'BREAKFAST',
  LUNCH: 'LUNCH',
  DINNER: 'DINNER',
} as const;

/**
 * 飲み物の種類
 */
export type FoodRecordCreateInputDtoBeverageType = typeof FoodRecordCreateInputDtoBeverageType[keyof typeof FoodRecordCreateInputDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordCreateInputDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface FoodRecordCreateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 食事の時間帯 */
  mealTime: FoodRecordCreateInputDtoMealTime;
  /**
   * 主食の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  mainCoursePercentage: number;
  /**
   * 副食の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  sideDishPercentage: number;
  /**
   * 汁物の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  soupPercentage: number;
  /** 飲み物の種類 */
  beverageType: FoodRecordCreateInputDtoBeverageType;
  /**
   * 飲み物の摂取量（ml）
   * @minimum 0
   */
  beverageVolume: number;
}

/**
 * 食事の時間帯
 */
export type FoodRecordUpdateInputDtoMealTime = typeof FoodRecordUpdateInputDtoMealTime[keyof typeof FoodRecordUpdateInputDtoMealTime];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordUpdateInputDtoMealTime = {
  BREAKFAST: 'BREAKFAST',
  LUNCH: 'LUNCH',
  DINNER: 'DINNER',
} as const;

/**
 * 飲み物の種類
 */
export type FoodRecordUpdateInputDtoBeverageType = typeof FoodRecordUpdateInputDtoBeverageType[keyof typeof FoodRecordUpdateInputDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordUpdateInputDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface FoodRecordUpdateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 食事の時間帯 */
  mealTime: FoodRecordUpdateInputDtoMealTime;
  /**
   * 主食の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  mainCoursePercentage: number;
  /**
   * 副食の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  sideDishPercentage: number;
  /**
   * 汁物の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  soupPercentage: number;
  /** 飲み物の種類 */
  beverageType: FoodRecordUpdateInputDtoBeverageType;
  /**
   * 飲み物の摂取量（ml）
   * @minimum 0
   */
  beverageVolume: number;
}

export interface BathRecordDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 介護者UID */
  caregiverUid: string;
  /** 利用者UID */
  residentUid: string;
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes: string;
  /** 入浴方法 */
  bathMethod: string;
}

export interface BathRecordListResponseDto {
  items: BathRecordDto[];
  /** 総件数 */
  total: number;
}

export interface BathRecordCreateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 入浴方法 */
  bathMethod: string;
}

export interface BathRecordUpdateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 入浴方法 */
  bathMethod: string;
}

export interface EliminationRecordDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 介護者UID */
  caregiverUid: string;
  /** 利用者UID */
  residentUid: string;
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes: string;
  /** 排泄方法 */
  eliminationMethod: string;
  /** 便の有無 */
  hasFeces: boolean;
  /** 便失禁の有無 */
  fecalIncontinence: boolean;
  /** 便の性状 */
  fecesAppearance: string;
  /** 便の量（g） */
  fecesVolume: number;
  /** 尿の有無 */
  hasUrine: boolean;
  /** 尿失禁の有無 */
  urinaryIncontinence: boolean;
  /** 尿の性状 */
  urineAppearance: string;
  /** 尿量（ml） */
  urineVolume: number;
}

export interface EliminationRecordListResponseDto {
  items: EliminationRecordDto[];
  /** 総件数 */
  total: number;
}

export interface EliminationRecordCreateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 排泄方法 */
  eliminationMethod: string;
  /** 便の有無 */
  hasFeces: boolean;
  /** 便失禁の有無 */
  fecalIncontinence?: boolean;
  /** 便の性状 */
  fecesAppearance?: string;
  /**
   * 便の量（g）
   * @minimum 0
   */
  fecesVolume?: number;
  /** 尿の有無 */
  hasUrine: boolean;
  /** 尿失禁の有無 */
  urinaryIncontinence?: boolean;
  /** 尿の性状 */
  urineAppearance?: string;
  /**
   * 尿量（ml）
   * @minimum 0
   */
  urineVolume?: number;
}

export interface EliminationRecordUpdateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 排泄方法 */
  eliminationMethod: string;
  /** 便の有無 */
  hasFeces: boolean;
  /** 便失禁の有無 */
  fecalIncontinence?: boolean;
  /** 便の性状 */
  fecesAppearance?: string;
  /**
   * 便の量（g）
   * @minimum 0
   */
  fecesVolume?: number;
  /** 尿の有無 */
  hasUrine: boolean;
  /** 尿失禁の有無 */
  urinaryIncontinence?: boolean;
  /** 尿の性状 */
  urineAppearance?: string;
  /**
   * 尿量（ml）
   * @minimum 0
   */
  urineVolume?: number;
}

/**
 * 日常の状態
 */
export type DailyRecordDtoDailyStatus = typeof DailyRecordDtoDailyStatus[keyof typeof DailyRecordDtoDailyStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DailyRecordDtoDailyStatus = {
  NORMAL: 'NORMAL',
  WARNING: 'WARNING',
  ALERT: 'ALERT',
} as const;

export interface DailyRecordDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 介護者UID */
  caregiverUid: string;
  /** 利用者UID */
  residentUid: string;
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes: string;
  /** 日常の状態 */
  dailyStatus: DailyRecordDtoDailyStatus;
}

export interface DailyRecordListResponseDto {
  items: DailyRecordDto[];
  /** 総件数 */
  total: number;
}

/**
 * 日常の状態
 */
export type DailyRecordCreateInputDtoDailyStatus = typeof DailyRecordCreateInputDtoDailyStatus[keyof typeof DailyRecordCreateInputDtoDailyStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DailyRecordCreateInputDtoDailyStatus = {
  NORMAL: 'NORMAL',
  WARNING: 'WARNING',
  ALERT: 'ALERT',
} as const;

export interface DailyRecordCreateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 日常の状態 */
  dailyStatus?: DailyRecordCreateInputDtoDailyStatus;
}

/**
 * 日常の状態
 */
export type DailyRecordUpdateInputDtoDailyStatus = typeof DailyRecordUpdateInputDtoDailyStatus[keyof typeof DailyRecordUpdateInputDtoDailyStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DailyRecordUpdateInputDtoDailyStatus = {
  NORMAL: 'NORMAL',
  WARNING: 'WARNING',
  ALERT: 'ALERT',
} as const;

export interface DailyRecordUpdateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 日常の状態 */
  dailyStatus?: DailyRecordUpdateInputDtoDailyStatus;
}

/**
 * 飲み物の種類
 */
export type BeverageRecordDtoBeverageType = typeof BeverageRecordDtoBeverageType[keyof typeof BeverageRecordDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BeverageRecordDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface BeverageRecordDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 介護者UID */
  caregiverUid: string;
  /** 利用者UID */
  residentUid: string;
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes: string;
  /** 飲み物の種類 */
  beverageType: BeverageRecordDtoBeverageType;
  /** 飲み物の量（ml） */
  volume: number;
}

export interface BeverageRecordListResponseDto {
  items: BeverageRecordDto[];
  /** 総件数 */
  total: number;
}

/**
 * 飲み物の種類
 */
export type BeverageRecordCreateInputDtoBeverageType = typeof BeverageRecordCreateInputDtoBeverageType[keyof typeof BeverageRecordCreateInputDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BeverageRecordCreateInputDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface BeverageRecordCreateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 飲み物の種類 */
  beverageType: BeverageRecordCreateInputDtoBeverageType;
  /**
   * 飲み物の量（ml）
   * @minimum 0
   */
  volume: number;
}

/**
 * 飲み物の種類
 */
export type BeverageRecordUpdateInputDtoBeverageType = typeof BeverageRecordUpdateInputDtoBeverageType[keyof typeof BeverageRecordUpdateInputDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BeverageRecordUpdateInputDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface BeverageRecordUpdateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 飲み物の種類 */
  beverageType: BeverageRecordUpdateInputDtoBeverageType;
  /**
   * 飲み物の量（ml）
   * @minimum 0
   */
  volume: number;
}





export const appControllerGetHello = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/`, method: 'GET', signal
    },
      );
    }
  

export const getAppControllerGetHelloQueryKey = () => {
    return [`/`] as const;
    }

    
export const getAppControllerGetHelloQueryOptions = <TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppControllerGetHelloQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerGetHello>>> = ({ signal }) => appControllerGetHello(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppControllerGetHelloQueryResult = NonNullable<Awaited<ReturnType<typeof appControllerGetHello>>>
export type AppControllerGetHelloQueryError = unknown


export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAppControllerGetHelloQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary ログイン
 */
export const login = (
    signInDto: SignInDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TokenDto>(
      {url: `/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: signInDto, signal
    },
      );
    }
  


export const getLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: SignInDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: SignInDto}, TContext> => {
    
const mutationKey = ['login'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: SignInDto}> = (props) => {
          const {data} = props ?? {};

          return  login(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = SignInDto
    export type LoginMutationError = unknown

    /**
 * @summary ログイン
 */
export const useLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: SignInDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: SignInDto},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ログイン中のユーザー情報を取得
 */
export const getMe = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserDto>(
      {url: `/auth/me`, method: 'GET', signal
    },
      );
    }
  

export const getGetMeQueryKey = () => {
    return [`/auth/me`] as const;
    }

    
export const getGetMeQueryOptions = <TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMe>>> = ({ signal }) => getMe(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMeQueryResult = NonNullable<Awaited<ReturnType<typeof getMe>>>
export type GetMeQueryError = unknown


export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ログイン中のユーザー情報を取得
 */

export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary テナント内のユーザー一覧を取得
 */
export const getUsers = (
    tenantUid?: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserListResponseDto>(
      {url: `/tenants/${tenantUid}/users`, method: 'GET', signal
    },
      );
    }
  

export const getGetUsersQueryKey = (tenantUid?: string,) => {
    return [`/tenants/${tenantUid}/users`] as const;
    }

    
export const getGetUsersQueryOptions = <TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersQueryKey(tenantUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(tenantUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(tenantUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersQueryError = unknown


export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
 tenantUid: undefined |  string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsers>>,
          TError,
          Awaited<ReturnType<typeof getUsers>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsers>>,
          TError,
          Awaited<ReturnType<typeof getUsers>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary テナント内のユーザー一覧を取得
 */

export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersQueryOptions(tenantUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary テナントにユーザーを作成
 */
export const createUser = (
    tenantUid: string,
    tenantUserCreateInputDto: TenantUserCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserDto>(
      {url: `/tenants/${tenantUid}/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tenantUserCreateInputDto, signal
    },
      );
    }
  


export const getCreateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{tenantUid: string;data: TenantUserCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{tenantUid: string;data: TenantUserCreateInputDto}, TContext> => {
    
const mutationKey = ['createUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {tenantUid: string;data: TenantUserCreateInputDto}> = (props) => {
          const {tenantUid,data} = props ?? {};

          return  createUser(tenantUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = TenantUserCreateInputDto
    export type CreateUserMutationError = unknown

    /**
 * @summary テナントにユーザーを作成
 */
export const useCreateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{tenantUid: string;data: TenantUserCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {tenantUid: string;data: TenantUserCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ユーザーを更新
 */
export const updateUser = (
    uid: string,
    userUpdateInputDto: UserUpdateInputDto,
 ) => {
      
      
      return customInstance<UserDto>(
      {url: `/users/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: userUpdateInputDto
    },
      );
    }
  


export const getUpdateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{uid: string;data: UserUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{uid: string;data: UserUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {uid: string;data: UserUpdateInputDto}> = (props) => {
          const {uid,data} = props ?? {};

          return  updateUser(uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UserUpdateInputDto
    export type UpdateUserMutationError = unknown

    /**
 * @summary ユーザーを更新
 */
export const useUpdateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{uid: string;data: UserUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {uid: string;data: UserUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ユーザーを削除
 */
export const deleteUser = (
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/users/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{uid: string}, TContext> => {
    
const mutationKey = ['deleteUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {uid: string}> = (props) => {
          const {uid} = props ?? {};

          return  deleteUser(uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = unknown

    /**
 * @summary ユーザーを削除
 */
export const useDeleteUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary テナント一覧を取得
 */
export const getTenants = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<TenantListResponseDto>(
      {url: `/tenants`, method: 'GET', signal
    },
      );
    }
  

export const getGetTenantsQueryKey = () => {
    return [`/tenants`] as const;
    }

    
export const getGetTenantsQueryOptions = <TData = Awaited<ReturnType<typeof getTenants>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenants>>> = ({ signal }) => getTenants(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTenantsQueryResult = NonNullable<Awaited<ReturnType<typeof getTenants>>>
export type GetTenantsQueryError = unknown


export function useGetTenants<TData = Awaited<ReturnType<typeof getTenants>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenants>>,
          TError,
          Awaited<ReturnType<typeof getTenants>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenants<TData = Awaited<ReturnType<typeof getTenants>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenants>>,
          TError,
          Awaited<ReturnType<typeof getTenants>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenants<TData = Awaited<ReturnType<typeof getTenants>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary テナント一覧を取得
 */

export function useGetTenants<TData = Awaited<ReturnType<typeof getTenants>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTenantsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary テナントを作成する
 */
export const createTenant = (
    tenantCreateInputDto: TenantCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TenantDto>(
      {url: `/tenants`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tenantCreateInputDto, signal
    },
      );
    }
  


export const getCreateTenantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTenant>>, TError,{data: TenantCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createTenant>>, TError,{data: TenantCreateInputDto}, TContext> => {
    
const mutationKey = ['createTenant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTenant>>, {data: TenantCreateInputDto}> = (props) => {
          const {data} = props ?? {};

          return  createTenant(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTenantMutationResult = NonNullable<Awaited<ReturnType<typeof createTenant>>>
    export type CreateTenantMutationBody = TenantCreateInputDto
    export type CreateTenantMutationError = unknown

    /**
 * @summary テナントを作成する
 */
export const useCreateTenant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTenant>>, TError,{data: TenantCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createTenant>>,
        TError,
        {data: TenantCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateTenantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary テナントの詳細を取得
 */
export const getTenant = (
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TenantDto>(
      {url: `/tenants/${uid}`, method: 'GET', signal
    },
      );
    }
  

export const getGetTenantQueryKey = (uid: string,) => {
    return [`/tenants/${uid}`] as const;
    }

    
export const getGetTenantQueryOptions = <TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantQueryKey(uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenant>>> = ({ signal }) => getTenant(uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTenantQueryResult = NonNullable<Awaited<ReturnType<typeof getTenant>>>
export type GetTenantQueryError = unknown


export function useGetTenant<TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(
 uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenant>>,
          TError,
          Awaited<ReturnType<typeof getTenant>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenant<TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenant>>,
          TError,
          Awaited<ReturnType<typeof getTenant>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenant<TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary テナントの詳細を取得
 */

export function useGetTenant<TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTenantQueryOptions(uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary テナントを更新
 */
export const updateTenant = (
    uid: string,
    tenantUpdateInputDto: TenantUpdateInputDto,
 ) => {
      
      
      return customInstance<TenantDto>(
      {url: `/tenants/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: tenantUpdateInputDto
    },
      );
    }
  


export const getUpdateTenantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTenant>>, TError,{uid: string;data: TenantUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateTenant>>, TError,{uid: string;data: TenantUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateTenant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTenant>>, {uid: string;data: TenantUpdateInputDto}> = (props) => {
          const {uid,data} = props ?? {};

          return  updateTenant(uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTenantMutationResult = NonNullable<Awaited<ReturnType<typeof updateTenant>>>
    export type UpdateTenantMutationBody = TenantUpdateInputDto
    export type UpdateTenantMutationError = unknown

    /**
 * @summary テナントを更新
 */
export const useUpdateTenant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTenant>>, TError,{uid: string;data: TenantUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateTenant>>,
        TError,
        {uid: string;data: TenantUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateTenantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary テナントを削除
 */
export const deleteTenant = (
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/tenants/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteTenantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTenant>>, TError,{uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteTenant>>, TError,{uid: string}, TContext> => {
    
const mutationKey = ['deleteTenant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTenant>>, {uid: string}> = (props) => {
          const {uid} = props ?? {};

          return  deleteTenant(uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTenantMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTenant>>>
    
    export type DeleteTenantMutationError = unknown

    /**
 * @summary テナントを削除
 */
export const useDeleteTenant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTenant>>, TError,{uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteTenant>>,
        TError,
        {uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteTenantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary テナント内の利用者一覧を取得
 */
export const getResidents = (
    tenantUid?: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResidentListResponseDto>(
      {url: `/tenants/${tenantUid}/residents`, method: 'GET', signal
    },
      );
    }
  

export const getGetResidentsQueryKey = (tenantUid?: string,) => {
    return [`/tenants/${tenantUid}/residents`] as const;
    }

    
export const getGetResidentsQueryOptions = <TData = Awaited<ReturnType<typeof getResidents>>, TError = unknown>(tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetResidentsQueryKey(tenantUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getResidents>>> = ({ signal }) => getResidents(tenantUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(tenantUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetResidentsQueryResult = NonNullable<Awaited<ReturnType<typeof getResidents>>>
export type GetResidentsQueryError = unknown


export function useGetResidents<TData = Awaited<ReturnType<typeof getResidents>>, TError = unknown>(
 tenantUid: undefined |  string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResidents>>,
          TError,
          Awaited<ReturnType<typeof getResidents>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResidents<TData = Awaited<ReturnType<typeof getResidents>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResidents>>,
          TError,
          Awaited<ReturnType<typeof getResidents>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResidents<TData = Awaited<ReturnType<typeof getResidents>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary テナント内の利用者一覧を取得
 */

export function useGetResidents<TData = Awaited<ReturnType<typeof getResidents>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetResidentsQueryOptions(tenantUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary テナントに利用者を作成
 */
export const createResident = (
    tenantUid: string,
    residentCreateInputDto: ResidentCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResidentDto>(
      {url: `/tenants/${tenantUid}/residents`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: residentCreateInputDto, signal
    },
      );
    }
  


export const getCreateResidentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createResident>>, TError,{tenantUid: string;data: ResidentCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createResident>>, TError,{tenantUid: string;data: ResidentCreateInputDto}, TContext> => {
    
const mutationKey = ['createResident'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createResident>>, {tenantUid: string;data: ResidentCreateInputDto}> = (props) => {
          const {tenantUid,data} = props ?? {};

          return  createResident(tenantUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateResidentMutationResult = NonNullable<Awaited<ReturnType<typeof createResident>>>
    export type CreateResidentMutationBody = ResidentCreateInputDto
    export type CreateResidentMutationError = unknown

    /**
 * @summary テナントに利用者を作成
 */
export const useCreateResident = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createResident>>, TError,{tenantUid: string;data: ResidentCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createResident>>,
        TError,
        {tenantUid: string;data: ResidentCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateResidentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の詳細を取得
 */
export const getResident = (
    tenantUid: string,
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResidentDto>(
      {url: `/tenants/${tenantUid}/residents/${uid}`, method: 'GET', signal
    },
      );
    }
  

export const getGetResidentQueryKey = (tenantUid: string,
    uid: string,) => {
    return [`/tenants/${tenantUid}/residents/${uid}`] as const;
    }

    
export const getGetResidentQueryOptions = <TData = Awaited<ReturnType<typeof getResident>>, TError = unknown>(tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetResidentQueryKey(tenantUid,uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getResident>>> = ({ signal }) => getResident(tenantUid,uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(tenantUid && uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetResidentQueryResult = NonNullable<Awaited<ReturnType<typeof getResident>>>
export type GetResidentQueryError = unknown


export function useGetResident<TData = Awaited<ReturnType<typeof getResident>>, TError = unknown>(
 tenantUid: string,
    uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResident>>,
          TError,
          Awaited<ReturnType<typeof getResident>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResident<TData = Awaited<ReturnType<typeof getResident>>, TError = unknown>(
 tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResident>>,
          TError,
          Awaited<ReturnType<typeof getResident>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResident<TData = Awaited<ReturnType<typeof getResident>>, TError = unknown>(
 tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の詳細を取得
 */

export function useGetResident<TData = Awaited<ReturnType<typeof getResident>>, TError = unknown>(
 tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetResidentQueryOptions(tenantUid,uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 利用者を更新
 */
export const updateResident = (
    tenantUid: string,
    uid: string,
    residentUpdateInputDto: ResidentUpdateInputDto,
 ) => {
      
      
      return customInstance<ResidentDto>(
      {url: `/tenants/${tenantUid}/residents/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: residentUpdateInputDto
    },
      );
    }
  


export const getUpdateResidentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateResident>>, TError,{tenantUid: string;uid: string;data: ResidentUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateResident>>, TError,{tenantUid: string;uid: string;data: ResidentUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateResident'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateResident>>, {tenantUid: string;uid: string;data: ResidentUpdateInputDto}> = (props) => {
          const {tenantUid,uid,data} = props ?? {};

          return  updateResident(tenantUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateResidentMutationResult = NonNullable<Awaited<ReturnType<typeof updateResident>>>
    export type UpdateResidentMutationBody = ResidentUpdateInputDto
    export type UpdateResidentMutationError = unknown

    /**
 * @summary 利用者を更新
 */
export const useUpdateResident = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateResident>>, TError,{tenantUid: string;uid: string;data: ResidentUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateResident>>,
        TError,
        {tenantUid: string;uid: string;data: ResidentUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateResidentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者を削除
 */
export const deleteResident = (
    tenantUid: string,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/tenants/${tenantUid}/residents/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteResidentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteResident>>, TError,{tenantUid: string;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteResident>>, TError,{tenantUid: string;uid: string}, TContext> => {
    
const mutationKey = ['deleteResident'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteResident>>, {tenantUid: string;uid: string}> = (props) => {
          const {tenantUid,uid} = props ?? {};

          return  deleteResident(tenantUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteResidentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteResident>>>
    
    export type DeleteResidentMutationError = unknown

    /**
 * @summary 利用者を削除
 */
export const useDeleteResident = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteResident>>, TError,{tenantUid: string;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteResident>>,
        TError,
        {tenantUid: string;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteResidentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の食事記録一覧を取得
 */
export const getFoodRecords = (
    residentUid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<FoodRecordListResponseDto>(
      {url: `/residents/${residentUid}/food-records`, method: 'GET', signal
    },
      );
    }
  

export const getGetFoodRecordsQueryKey = (residentUid: string,) => {
    return [`/residents/${residentUid}/food-records`] as const;
    }

    
export const getGetFoodRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getFoodRecords>>, TError = unknown>(residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFoodRecordsQueryKey(residentUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFoodRecords>>> = ({ signal }) => getFoodRecords(residentUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFoodRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getFoodRecords>>>
export type GetFoodRecordsQueryError = unknown


export function useGetFoodRecords<TData = Awaited<ReturnType<typeof getFoodRecords>>, TError = unknown>(
 residentUid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFoodRecords>>,
          TError,
          Awaited<ReturnType<typeof getFoodRecords>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoodRecords<TData = Awaited<ReturnType<typeof getFoodRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFoodRecords>>,
          TError,
          Awaited<ReturnType<typeof getFoodRecords>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoodRecords<TData = Awaited<ReturnType<typeof getFoodRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の食事記録一覧を取得
 */

export function useGetFoodRecords<TData = Awaited<ReturnType<typeof getFoodRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFoodRecordsQueryOptions(residentUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 食事記録を作成
 */
export const createFoodRecord = (
    residentUid: string,
    foodRecordCreateInputDto: FoodRecordCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<FoodRecordDto>(
      {url: `/residents/${residentUid}/food-records`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: foodRecordCreateInputDto, signal
    },
      );
    }
  


export const getCreateFoodRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFoodRecord>>, TError,{residentUid: string;data: FoodRecordCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createFoodRecord>>, TError,{residentUid: string;data: FoodRecordCreateInputDto}, TContext> => {
    
const mutationKey = ['createFoodRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createFoodRecord>>, {residentUid: string;data: FoodRecordCreateInputDto}> = (props) => {
          const {residentUid,data} = props ?? {};

          return  createFoodRecord(residentUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateFoodRecordMutationResult = NonNullable<Awaited<ReturnType<typeof createFoodRecord>>>
    export type CreateFoodRecordMutationBody = FoodRecordCreateInputDto
    export type CreateFoodRecordMutationError = unknown

    /**
 * @summary 食事記録を作成
 */
export const useCreateFoodRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFoodRecord>>, TError,{residentUid: string;data: FoodRecordCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createFoodRecord>>,
        TError,
        {residentUid: string;data: FoodRecordCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateFoodRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 食事記録を更新
 */
export const updateFoodRecord = (
    residentUid: unknown,
    uid: string,
    foodRecordUpdateInputDto: FoodRecordUpdateInputDto,
 ) => {
      
      
      return customInstance<FoodRecordDto>(
      {url: `/residents/${residentUid}/food-records/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: foodRecordUpdateInputDto
    },
      );
    }
  


export const getUpdateFoodRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFoodRecord>>, TError,{residentUid: unknown;uid: string;data: FoodRecordUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateFoodRecord>>, TError,{residentUid: unknown;uid: string;data: FoodRecordUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateFoodRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateFoodRecord>>, {residentUid: unknown;uid: string;data: FoodRecordUpdateInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateFoodRecord(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateFoodRecordMutationResult = NonNullable<Awaited<ReturnType<typeof updateFoodRecord>>>
    export type UpdateFoodRecordMutationBody = FoodRecordUpdateInputDto
    export type UpdateFoodRecordMutationError = unknown

    /**
 * @summary 食事記録を更新
 */
export const useUpdateFoodRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFoodRecord>>, TError,{residentUid: unknown;uid: string;data: FoodRecordUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateFoodRecord>>,
        TError,
        {residentUid: unknown;uid: string;data: FoodRecordUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateFoodRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 食事記録を削除
 */
export const deleteFoodRecord = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/food-records/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteFoodRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteFoodRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteFoodRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteFoodRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteFoodRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteFoodRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteFoodRecordMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFoodRecord>>>
    
    export type DeleteFoodRecordMutationError = unknown

    /**
 * @summary 食事記録を削除
 */
export const useDeleteFoodRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteFoodRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteFoodRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteFoodRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の入浴記録一覧を取得
 */
export const getBathRecords = (
    residentUid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BathRecordListResponseDto>(
      {url: `/residents/${residentUid}/bath-records`, method: 'GET', signal
    },
      );
    }
  

export const getGetBathRecordsQueryKey = (residentUid: string,) => {
    return [`/residents/${residentUid}/bath-records`] as const;
    }

    
export const getGetBathRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getBathRecords>>, TError = unknown>(residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBathRecordsQueryKey(residentUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBathRecords>>> = ({ signal }) => getBathRecords(residentUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBathRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getBathRecords>>>
export type GetBathRecordsQueryError = unknown


export function useGetBathRecords<TData = Awaited<ReturnType<typeof getBathRecords>>, TError = unknown>(
 residentUid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBathRecords>>,
          TError,
          Awaited<ReturnType<typeof getBathRecords>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBathRecords<TData = Awaited<ReturnType<typeof getBathRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBathRecords>>,
          TError,
          Awaited<ReturnType<typeof getBathRecords>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBathRecords<TData = Awaited<ReturnType<typeof getBathRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の入浴記録一覧を取得
 */

export function useGetBathRecords<TData = Awaited<ReturnType<typeof getBathRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBathRecordsQueryOptions(residentUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 入浴記録を作成
 */
export const createBathRecord = (
    residentUid: string,
    bathRecordCreateInputDto: BathRecordCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BathRecordDto>(
      {url: `/residents/${residentUid}/bath-records`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bathRecordCreateInputDto, signal
    },
      );
    }
  


export const getCreateBathRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBathRecord>>, TError,{residentUid: string;data: BathRecordCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createBathRecord>>, TError,{residentUid: string;data: BathRecordCreateInputDto}, TContext> => {
    
const mutationKey = ['createBathRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBathRecord>>, {residentUid: string;data: BathRecordCreateInputDto}> = (props) => {
          const {residentUid,data} = props ?? {};

          return  createBathRecord(residentUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBathRecordMutationResult = NonNullable<Awaited<ReturnType<typeof createBathRecord>>>
    export type CreateBathRecordMutationBody = BathRecordCreateInputDto
    export type CreateBathRecordMutationError = unknown

    /**
 * @summary 入浴記録を作成
 */
export const useCreateBathRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBathRecord>>, TError,{residentUid: string;data: BathRecordCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createBathRecord>>,
        TError,
        {residentUid: string;data: BathRecordCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateBathRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 入浴記録を更新
 */
export const updateBathRecord = (
    residentUid: unknown,
    uid: string,
    bathRecordUpdateInputDto: BathRecordUpdateInputDto,
 ) => {
      
      
      return customInstance<BathRecordDto>(
      {url: `/residents/${residentUid}/bath-records/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: bathRecordUpdateInputDto
    },
      );
    }
  


export const getUpdateBathRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBathRecord>>, TError,{residentUid: unknown;uid: string;data: BathRecordUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBathRecord>>, TError,{residentUid: unknown;uid: string;data: BathRecordUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateBathRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBathRecord>>, {residentUid: unknown;uid: string;data: BathRecordUpdateInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateBathRecord(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBathRecordMutationResult = NonNullable<Awaited<ReturnType<typeof updateBathRecord>>>
    export type UpdateBathRecordMutationBody = BathRecordUpdateInputDto
    export type UpdateBathRecordMutationError = unknown

    /**
 * @summary 入浴記録を更新
 */
export const useUpdateBathRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBathRecord>>, TError,{residentUid: unknown;uid: string;data: BathRecordUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateBathRecord>>,
        TError,
        {residentUid: unknown;uid: string;data: BathRecordUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateBathRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 入浴記録を削除
 */
export const deleteBathRecord = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/bath-records/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBathRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBathRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteBathRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteBathRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBathRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteBathRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBathRecordMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBathRecord>>>
    
    export type DeleteBathRecordMutationError = unknown

    /**
 * @summary 入浴記録を削除
 */
export const useDeleteBathRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBathRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteBathRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteBathRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の排泄記録一覧を取得
 */
export const getEliminationRecords = (
    residentUid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<EliminationRecordListResponseDto>(
      {url: `/residents/${residentUid}/elimination-records`, method: 'GET', signal
    },
      );
    }
  

export const getGetEliminationRecordsQueryKey = (residentUid: string,) => {
    return [`/residents/${residentUid}/elimination-records`] as const;
    }

    
export const getGetEliminationRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getEliminationRecords>>, TError = unknown>(residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEliminationRecordsQueryKey(residentUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEliminationRecords>>> = ({ signal }) => getEliminationRecords(residentUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEliminationRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getEliminationRecords>>>
export type GetEliminationRecordsQueryError = unknown


export function useGetEliminationRecords<TData = Awaited<ReturnType<typeof getEliminationRecords>>, TError = unknown>(
 residentUid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEliminationRecords>>,
          TError,
          Awaited<ReturnType<typeof getEliminationRecords>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEliminationRecords<TData = Awaited<ReturnType<typeof getEliminationRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEliminationRecords>>,
          TError,
          Awaited<ReturnType<typeof getEliminationRecords>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEliminationRecords<TData = Awaited<ReturnType<typeof getEliminationRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の排泄記録一覧を取得
 */

export function useGetEliminationRecords<TData = Awaited<ReturnType<typeof getEliminationRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEliminationRecordsQueryOptions(residentUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 排泄記録を作成
 */
export const createEliminationRecord = (
    residentUid: string,
    eliminationRecordCreateInputDto: EliminationRecordCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<EliminationRecordDto>(
      {url: `/residents/${residentUid}/elimination-records`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: eliminationRecordCreateInputDto, signal
    },
      );
    }
  


export const getCreateEliminationRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEliminationRecord>>, TError,{residentUid: string;data: EliminationRecordCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createEliminationRecord>>, TError,{residentUid: string;data: EliminationRecordCreateInputDto}, TContext> => {
    
const mutationKey = ['createEliminationRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createEliminationRecord>>, {residentUid: string;data: EliminationRecordCreateInputDto}> = (props) => {
          const {residentUid,data} = props ?? {};

          return  createEliminationRecord(residentUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateEliminationRecordMutationResult = NonNullable<Awaited<ReturnType<typeof createEliminationRecord>>>
    export type CreateEliminationRecordMutationBody = EliminationRecordCreateInputDto
    export type CreateEliminationRecordMutationError = unknown

    /**
 * @summary 排泄記録を作成
 */
export const useCreateEliminationRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEliminationRecord>>, TError,{residentUid: string;data: EliminationRecordCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createEliminationRecord>>,
        TError,
        {residentUid: string;data: EliminationRecordCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateEliminationRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 排泄記録を更新
 */
export const updateEliminationRecord = (
    residentUid: unknown,
    uid: string,
    eliminationRecordUpdateInputDto: EliminationRecordUpdateInputDto,
 ) => {
      
      
      return customInstance<EliminationRecordDto>(
      {url: `/residents/${residentUid}/elimination-records/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: eliminationRecordUpdateInputDto
    },
      );
    }
  


export const getUpdateEliminationRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEliminationRecord>>, TError,{residentUid: unknown;uid: string;data: EliminationRecordUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateEliminationRecord>>, TError,{residentUid: unknown;uid: string;data: EliminationRecordUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateEliminationRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEliminationRecord>>, {residentUid: unknown;uid: string;data: EliminationRecordUpdateInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateEliminationRecord(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateEliminationRecordMutationResult = NonNullable<Awaited<ReturnType<typeof updateEliminationRecord>>>
    export type UpdateEliminationRecordMutationBody = EliminationRecordUpdateInputDto
    export type UpdateEliminationRecordMutationError = unknown

    /**
 * @summary 排泄記録を更新
 */
export const useUpdateEliminationRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEliminationRecord>>, TError,{residentUid: unknown;uid: string;data: EliminationRecordUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateEliminationRecord>>,
        TError,
        {residentUid: unknown;uid: string;data: EliminationRecordUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateEliminationRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 排泄記録を削除
 */
export const deleteEliminationRecord = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/elimination-records/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteEliminationRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEliminationRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteEliminationRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteEliminationRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEliminationRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteEliminationRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteEliminationRecordMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEliminationRecord>>>
    
    export type DeleteEliminationRecordMutationError = unknown

    /**
 * @summary 排泄記録を削除
 */
export const useDeleteEliminationRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEliminationRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteEliminationRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteEliminationRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の日常記録一覧を取得
 */
export const getDailyRecords = (
    residentUid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<DailyRecordListResponseDto>(
      {url: `/residents/${residentUid}/daily-records`, method: 'GET', signal
    },
      );
    }
  

export const getGetDailyRecordsQueryKey = (residentUid: string,) => {
    return [`/residents/${residentUid}/daily-records`] as const;
    }

    
export const getGetDailyRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getDailyRecords>>, TError = unknown>(residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDailyRecordsQueryKey(residentUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDailyRecords>>> = ({ signal }) => getDailyRecords(residentUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDailyRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getDailyRecords>>>
export type GetDailyRecordsQueryError = unknown


export function useGetDailyRecords<TData = Awaited<ReturnType<typeof getDailyRecords>>, TError = unknown>(
 residentUid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDailyRecords>>,
          TError,
          Awaited<ReturnType<typeof getDailyRecords>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDailyRecords<TData = Awaited<ReturnType<typeof getDailyRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDailyRecords>>,
          TError,
          Awaited<ReturnType<typeof getDailyRecords>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDailyRecords<TData = Awaited<ReturnType<typeof getDailyRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の日常記録一覧を取得
 */

export function useGetDailyRecords<TData = Awaited<ReturnType<typeof getDailyRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDailyRecordsQueryOptions(residentUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 日常記録を作成
 */
export const createDailyRecord = (
    residentUid: string,
    dailyRecordCreateInputDto: DailyRecordCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<DailyRecordDto>(
      {url: `/residents/${residentUid}/daily-records`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: dailyRecordCreateInputDto, signal
    },
      );
    }
  


export const getCreateDailyRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDailyRecord>>, TError,{residentUid: string;data: DailyRecordCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createDailyRecord>>, TError,{residentUid: string;data: DailyRecordCreateInputDto}, TContext> => {
    
const mutationKey = ['createDailyRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDailyRecord>>, {residentUid: string;data: DailyRecordCreateInputDto}> = (props) => {
          const {residentUid,data} = props ?? {};

          return  createDailyRecord(residentUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDailyRecordMutationResult = NonNullable<Awaited<ReturnType<typeof createDailyRecord>>>
    export type CreateDailyRecordMutationBody = DailyRecordCreateInputDto
    export type CreateDailyRecordMutationError = unknown

    /**
 * @summary 日常記録を作成
 */
export const useCreateDailyRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDailyRecord>>, TError,{residentUid: string;data: DailyRecordCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createDailyRecord>>,
        TError,
        {residentUid: string;data: DailyRecordCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateDailyRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 日常記録を更新
 */
export const updateDailyRecord = (
    residentUid: unknown,
    uid: string,
    dailyRecordUpdateInputDto: DailyRecordUpdateInputDto,
 ) => {
      
      
      return customInstance<DailyRecordDto>(
      {url: `/residents/${residentUid}/daily-records/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: dailyRecordUpdateInputDto
    },
      );
    }
  


export const getUpdateDailyRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDailyRecord>>, TError,{residentUid: unknown;uid: string;data: DailyRecordUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateDailyRecord>>, TError,{residentUid: unknown;uid: string;data: DailyRecordUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateDailyRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDailyRecord>>, {residentUid: unknown;uid: string;data: DailyRecordUpdateInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateDailyRecord(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDailyRecordMutationResult = NonNullable<Awaited<ReturnType<typeof updateDailyRecord>>>
    export type UpdateDailyRecordMutationBody = DailyRecordUpdateInputDto
    export type UpdateDailyRecordMutationError = unknown

    /**
 * @summary 日常記録を更新
 */
export const useUpdateDailyRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDailyRecord>>, TError,{residentUid: unknown;uid: string;data: DailyRecordUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateDailyRecord>>,
        TError,
        {residentUid: unknown;uid: string;data: DailyRecordUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateDailyRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 日常記録を削除
 */
export const deleteDailyRecord = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/daily-records/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteDailyRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDailyRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteDailyRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteDailyRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDailyRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteDailyRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDailyRecordMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDailyRecord>>>
    
    export type DeleteDailyRecordMutationError = unknown

    /**
 * @summary 日常記録を削除
 */
export const useDeleteDailyRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDailyRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteDailyRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteDailyRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の飲料記録一覧を取得
 */
export const getBeverageRecords = (
    residentUid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BeverageRecordListResponseDto>(
      {url: `/residents/${residentUid}/beverage-records`, method: 'GET', signal
    },
      );
    }
  

export const getGetBeverageRecordsQueryKey = (residentUid: string,) => {
    return [`/residents/${residentUid}/beverage-records`] as const;
    }

    
export const getGetBeverageRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getBeverageRecords>>, TError = unknown>(residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBeverageRecordsQueryKey(residentUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBeverageRecords>>> = ({ signal }) => getBeverageRecords(residentUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBeverageRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getBeverageRecords>>>
export type GetBeverageRecordsQueryError = unknown


export function useGetBeverageRecords<TData = Awaited<ReturnType<typeof getBeverageRecords>>, TError = unknown>(
 residentUid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBeverageRecords>>,
          TError,
          Awaited<ReturnType<typeof getBeverageRecords>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBeverageRecords<TData = Awaited<ReturnType<typeof getBeverageRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBeverageRecords>>,
          TError,
          Awaited<ReturnType<typeof getBeverageRecords>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBeverageRecords<TData = Awaited<ReturnType<typeof getBeverageRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の飲料記録一覧を取得
 */

export function useGetBeverageRecords<TData = Awaited<ReturnType<typeof getBeverageRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBeverageRecordsQueryOptions(residentUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 飲料記録を作成
 */
export const createBeverageRecord = (
    residentUid: string,
    beverageRecordCreateInputDto: BeverageRecordCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BeverageRecordDto>(
      {url: `/residents/${residentUid}/beverage-records`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: beverageRecordCreateInputDto, signal
    },
      );
    }
  


export const getCreateBeverageRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBeverageRecord>>, TError,{residentUid: string;data: BeverageRecordCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createBeverageRecord>>, TError,{residentUid: string;data: BeverageRecordCreateInputDto}, TContext> => {
    
const mutationKey = ['createBeverageRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBeverageRecord>>, {residentUid: string;data: BeverageRecordCreateInputDto}> = (props) => {
          const {residentUid,data} = props ?? {};

          return  createBeverageRecord(residentUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBeverageRecordMutationResult = NonNullable<Awaited<ReturnType<typeof createBeverageRecord>>>
    export type CreateBeverageRecordMutationBody = BeverageRecordCreateInputDto
    export type CreateBeverageRecordMutationError = unknown

    /**
 * @summary 飲料記録を作成
 */
export const useCreateBeverageRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBeverageRecord>>, TError,{residentUid: string;data: BeverageRecordCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createBeverageRecord>>,
        TError,
        {residentUid: string;data: BeverageRecordCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateBeverageRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 飲料記録を更新
 */
export const updateBeverageRecord = (
    residentUid: unknown,
    uid: string,
    beverageRecordUpdateInputDto: BeverageRecordUpdateInputDto,
 ) => {
      
      
      return customInstance<BeverageRecordDto>(
      {url: `/residents/${residentUid}/beverage-records/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: beverageRecordUpdateInputDto
    },
      );
    }
  


export const getUpdateBeverageRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBeverageRecord>>, TError,{residentUid: unknown;uid: string;data: BeverageRecordUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBeverageRecord>>, TError,{residentUid: unknown;uid: string;data: BeverageRecordUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateBeverageRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBeverageRecord>>, {residentUid: unknown;uid: string;data: BeverageRecordUpdateInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateBeverageRecord(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBeverageRecordMutationResult = NonNullable<Awaited<ReturnType<typeof updateBeverageRecord>>>
    export type UpdateBeverageRecordMutationBody = BeverageRecordUpdateInputDto
    export type UpdateBeverageRecordMutationError = unknown

    /**
 * @summary 飲料記録を更新
 */
export const useUpdateBeverageRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBeverageRecord>>, TError,{residentUid: unknown;uid: string;data: BeverageRecordUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateBeverageRecord>>,
        TError,
        {residentUid: unknown;uid: string;data: BeverageRecordUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateBeverageRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 飲料記録を削除
 */
export const deleteBeverageRecord = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/beverage-records/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBeverageRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBeverageRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteBeverageRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteBeverageRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBeverageRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteBeverageRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBeverageRecordMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBeverageRecord>>>
    
    export type DeleteBeverageRecordMutationError = unknown

    /**
 * @summary 飲料記録を削除
 */
export const useDeleteBeverageRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBeverageRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteBeverageRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteBeverageRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
