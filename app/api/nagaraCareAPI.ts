/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Nagara Care API
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import { customInstance } from './custom-instance';
export interface SignInDto {
  loginId: string;
  password: string;
}

export interface TokenDto {
  /** JWTトークン */
  token: string;
}

export interface UserDto {
  /** ユーザーUID */
  uid: string;
  /** ログインID */
  loginId: string;
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** ユーザー権限 */
  role: string;
  /** テナントUID */
  tenantUid: string;
}

/**
 * ロール
 */
export type UserListItemDtoRole = typeof UserListItemDtoRole[keyof typeof UserListItemDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserListItemDtoRole = {
  GLOBAL_ADMIN: 'GLOBAL_ADMIN',
  TENANT_ADMIN: 'TENANT_ADMIN',
  CAREGIVER: 'CAREGIVER',
} as const;

export interface UserListItemDto {
  /** ユーザーUID */
  uid: string;
  /** ログインID */
  loginId: string;
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** ロール */
  role: UserListItemDtoRole;
  /** 作成日時 */
  createdAt: string;
}

export interface UserListResponseDto {
  /** ユーザー一覧 */
  items: UserListItemDto[];
  /** 総件数 */
  total: number;
}

export interface TenantUserCreateInputDto {
  /** ログインID */
  loginId: string;
  /** パスワード */
  password: string;
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** ユーザー権限 */
  role: string;
}

/**
 * ユーザーロール
 */
export type UserUpdateInputDtoRole = typeof UserUpdateInputDtoRole[keyof typeof UserUpdateInputDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserUpdateInputDtoRole = {
  GLOBAL_ADMIN: 'GLOBAL_ADMIN',
  TENANT_ADMIN: 'TENANT_ADMIN',
  CAREGIVER: 'CAREGIVER',
} as const;

export interface UserUpdateInputDto {
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** ユーザーロール */
  role: UserUpdateInputDtoRole;
}

export interface TenantListItemDto {
  /** テナントUID */
  uid: string;
  /** テナント名 */
  name: string;
  /** 作成日時 */
  createdAt: string;
}

export interface TenantListResponseDto {
  /** テナント一覧 */
  items: TenantListItemDto[];
  /** 総件数 */
  total: number;
}

export interface TenantDto {
  /** テナントUID */
  uid: string;
  /** テナント名 */
  name: string;
  /** 作成日時 */
  createdAt: string;
}

export interface TenantCreateInputDto {
  /** テナント名 */
  name: string;
}

export interface TenantUpdateInputDto {
  /** テナント名 */
  name: string;
}

/**
 * 性別
 */
export type ResidentDtoGender = typeof ResidentDtoGender[keyof typeof ResidentDtoGender];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResidentDtoGender = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
} as const;

export interface ResidentDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** 生年月日 */
  dateOfBirth: string;
  /** 性別 */
  gender: ResidentDtoGender;
  /** 入所日 */
  admissionDate: string;
  /** 作成日時 */
  createdAt: string;
}

export interface ResidentListResponseDto {
  items: ResidentDto[];
  /** 総件数 */
  total: number;
}

/**
 * 性別
 */
export type ResidentCreateInputDtoGender = typeof ResidentCreateInputDtoGender[keyof typeof ResidentCreateInputDtoGender];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResidentCreateInputDtoGender = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
} as const;

export interface ResidentCreateInputDto {
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** 生年月日 */
  dateOfBirth: string;
  /** 性別 */
  gender: ResidentCreateInputDtoGender;
  /** 入所日 */
  admissionDate: string;
}

/**
 * 性別
 */
export type ResidentUpdateInputDtoGender = typeof ResidentUpdateInputDtoGender[keyof typeof ResidentUpdateInputDtoGender];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResidentUpdateInputDtoGender = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
} as const;

export interface ResidentUpdateInputDto {
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** 生年月日 */
  dateOfBirth: string;
  /** 性別 */
  gender: ResidentUpdateInputDtoGender;
  /** 入所日 */
  admissionDate: string;
}

/**
 * 食事の時間帯
 */
export type FoodRecordDtoMealTime = typeof FoodRecordDtoMealTime[keyof typeof FoodRecordDtoMealTime];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordDtoMealTime = {
  BREAKFAST: 'BREAKFAST',
  LUNCH: 'LUNCH',
  DINNER: 'DINNER',
} as const;

/**
 * 飲み物の種類
 */
export type FoodRecordDtoBeverageType = typeof FoodRecordDtoBeverageType[keyof typeof FoodRecordDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface FoodRecordDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 介護者UID */
  caregiverUid: string;
  /** 利用者UID */
  residentUid: string;
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes: string;
  /** 食事の時間帯 */
  mealTime: FoodRecordDtoMealTime;
  /** 主食の摂取率（%） */
  mainCoursePercentage: number;
  /** 副食の摂取率（%） */
  sideDishPercentage: number;
  /** 汁物の摂取率（%） */
  soupPercentage: number;
  /** 飲み物の種類 */
  beverageType: FoodRecordDtoBeverageType;
  /** 飲み物の摂取量（ml） */
  beverageVolume: number;
}

export interface FoodRecordListResponseDto {
  items: FoodRecordDto[];
  /** 総件数 */
  total: number;
}

export interface DailyFoodRecordsDto {
  /** 日付 */
  date: string;
  /** 朝食の記録 */
  breakfast?: FoodRecordDto;
  /** 昼食の記録 */
  lunch?: FoodRecordDto;
  /** 夕食の記録 */
  dinner?: FoodRecordDto;
}

export interface DailyFoodRecordsListResponseDto {
  /** 日別食事記録一覧 */
  items: DailyFoodRecordsDto[];
  /** 総日数 */
  total: number;
}

/**
 * 食事の時間帯
 */
export type FoodRecordCreateInputDtoMealTime = typeof FoodRecordCreateInputDtoMealTime[keyof typeof FoodRecordCreateInputDtoMealTime];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordCreateInputDtoMealTime = {
  BREAKFAST: 'BREAKFAST',
  LUNCH: 'LUNCH',
  DINNER: 'DINNER',
} as const;

/**
 * 飲み物の種類
 */
export type FoodRecordCreateInputDtoBeverageType = typeof FoodRecordCreateInputDtoBeverageType[keyof typeof FoodRecordCreateInputDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordCreateInputDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface FoodRecordCreateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 食事の時間帯 */
  mealTime: FoodRecordCreateInputDtoMealTime;
  /**
   * 主食の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  mainCoursePercentage: number;
  /**
   * 副食の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  sideDishPercentage: number;
  /**
   * 汁物の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  soupPercentage: number;
  /** 飲み物の種類 */
  beverageType: FoodRecordCreateInputDtoBeverageType;
  /**
   * 飲み物の摂取量（ml）
   * @minimum 0
   */
  beverageVolume: number;
}

/**
 * 食事の時間帯
 */
export type FoodRecordUpdateInputDtoMealTime = typeof FoodRecordUpdateInputDtoMealTime[keyof typeof FoodRecordUpdateInputDtoMealTime];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordUpdateInputDtoMealTime = {
  BREAKFAST: 'BREAKFAST',
  LUNCH: 'LUNCH',
  DINNER: 'DINNER',
} as const;

/**
 * 飲み物の種類
 */
export type FoodRecordUpdateInputDtoBeverageType = typeof FoodRecordUpdateInputDtoBeverageType[keyof typeof FoodRecordUpdateInputDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordUpdateInputDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface FoodRecordUpdateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 食事の時間帯 */
  mealTime: FoodRecordUpdateInputDtoMealTime;
  /**
   * 主食の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  mainCoursePercentage: number;
  /**
   * 副食の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  sideDishPercentage: number;
  /**
   * 汁物の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  soupPercentage: number;
  /** 飲み物の種類 */
  beverageType: FoodRecordUpdateInputDtoBeverageType;
  /**
   * 飲み物の摂取量（ml）
   * @minimum 0
   */
  beverageVolume: number;
}

export interface BathRecordDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 介護者UID */
  caregiverUid: string;
  /** 利用者UID */
  residentUid: string;
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes: string;
  /** 入浴方法 */
  bathMethod: string;
}

export interface BathRecordListResponseDto {
  items: BathRecordDto[];
  /** 総件数 */
  total: number;
}

export interface BathRecordCreateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 入浴方法 */
  bathMethod: string;
}

export interface BathRecordUpdateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 入浴方法 */
  bathMethod: string;
}

export interface EliminationRecordDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 介護者UID */
  caregiverUid: string;
  /** 利用者UID */
  residentUid: string;
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes: string;
  /** 排泄方法 */
  eliminationMethod: string;
  /** 便の有無 */
  hasFeces: boolean;
  /** 便失禁の有無 */
  fecalIncontinence: boolean;
  /** 便の性状 */
  fecesAppearance: string;
  /** 便の量（g） */
  fecesVolume: number;
  /** 尿の有無 */
  hasUrine: boolean;
  /** 尿失禁の有無 */
  urinaryIncontinence: boolean;
  /** 尿の性状 */
  urineAppearance: string;
  /** 尿量（ml） */
  urineVolume: number;
}

export interface EliminationRecordListResponseDto {
  items: EliminationRecordDto[];
  /** 総件数 */
  total: number;
}

export interface EliminationRecordCreateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 排泄方法 */
  eliminationMethod: string;
  /** 便の有無 */
  hasFeces: boolean;
  /** 便失禁の有無 */
  fecalIncontinence?: boolean;
  /** 便の性状 */
  fecesAppearance?: string;
  /**
   * 便の量（g）
   * @minimum 0
   */
  fecesVolume?: number;
  /** 尿の有無 */
  hasUrine: boolean;
  /** 尿失禁の有無 */
  urinaryIncontinence?: boolean;
  /** 尿の性状 */
  urineAppearance?: string;
  /**
   * 尿量（ml）
   * @minimum 0
   */
  urineVolume?: number;
}

export interface EliminationRecordUpdateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 排泄方法 */
  eliminationMethod: string;
  /** 便の有無 */
  hasFeces: boolean;
  /** 便失禁の有無 */
  fecalIncontinence?: boolean;
  /** 便の性状 */
  fecesAppearance?: string;
  /**
   * 便の量（g）
   * @minimum 0
   */
  fecesVolume?: number;
  /** 尿の有無 */
  hasUrine: boolean;
  /** 尿失禁の有無 */
  urinaryIncontinence?: boolean;
  /** 尿の性状 */
  urineAppearance?: string;
  /**
   * 尿量（ml）
   * @minimum 0
   */
  urineVolume?: number;
}

/**
 * 日常の状態
 */
export type DailyRecordDtoDailyStatus = typeof DailyRecordDtoDailyStatus[keyof typeof DailyRecordDtoDailyStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DailyRecordDtoDailyStatus = {
  NORMAL: 'NORMAL',
  WARNING: 'WARNING',
  ALERT: 'ALERT',
} as const;

export interface DailyRecordDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 介護者UID */
  caregiverUid: string;
  /** 利用者UID */
  residentUid: string;
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes: string;
  /** 日常の状態 */
  dailyStatus: DailyRecordDtoDailyStatus;
}

export interface DailyRecordListResponseDto {
  items: DailyRecordDto[];
  /** 総件数 */
  total: number;
}

/**
 * 日常の状態
 */
export type DailyRecordCreateInputDtoDailyStatus = typeof DailyRecordCreateInputDtoDailyStatus[keyof typeof DailyRecordCreateInputDtoDailyStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DailyRecordCreateInputDtoDailyStatus = {
  NORMAL: 'NORMAL',
  WARNING: 'WARNING',
  ALERT: 'ALERT',
} as const;

export interface DailyRecordCreateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 日常の状態 */
  dailyStatus?: DailyRecordCreateInputDtoDailyStatus;
}

/**
 * 日常の状態
 */
export type DailyRecordUpdateInputDtoDailyStatus = typeof DailyRecordUpdateInputDtoDailyStatus[keyof typeof DailyRecordUpdateInputDtoDailyStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DailyRecordUpdateInputDtoDailyStatus = {
  NORMAL: 'NORMAL',
  WARNING: 'WARNING',
  ALERT: 'ALERT',
} as const;

export interface DailyRecordUpdateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 日常の状態 */
  dailyStatus?: DailyRecordUpdateInputDtoDailyStatus;
}

/**
 * 飲み物の種類
 */
export type BeverageRecordDtoBeverageType = typeof BeverageRecordDtoBeverageType[keyof typeof BeverageRecordDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BeverageRecordDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface BeverageRecordDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 介護者UID */
  caregiverUid: string;
  /** 利用者UID */
  residentUid: string;
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes: string;
  /** 飲み物の種類 */
  beverageType: BeverageRecordDtoBeverageType;
  /** 飲み物の量（ml） */
  volume: number;
}

export interface BeverageRecordListResponseDto {
  items: BeverageRecordDto[];
  /** 総件数 */
  total: number;
}

/**
 * 飲み物の種類
 */
export type BeverageRecordCreateInputDtoBeverageType = typeof BeverageRecordCreateInputDtoBeverageType[keyof typeof BeverageRecordCreateInputDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BeverageRecordCreateInputDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface BeverageRecordCreateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 飲み物の種類 */
  beverageType: BeverageRecordCreateInputDtoBeverageType;
  /**
   * 飲み物の量（ml）
   * @minimum 0
   */
  volume: number;
}

/**
 * 飲み物の種類
 */
export type BeverageRecordUpdateInputDtoBeverageType = typeof BeverageRecordUpdateInputDtoBeverageType[keyof typeof BeverageRecordUpdateInputDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BeverageRecordUpdateInputDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface BeverageRecordUpdateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 飲み物の種類 */
  beverageType: BeverageRecordUpdateInputDtoBeverageType;
  /**
   * 飲み物の量（ml）
   * @minimum 0
   */
  volume: number;
}

/**
 * 性別
 */
export type SubjectDtoGender = typeof SubjectDtoGender[keyof typeof SubjectDtoGender];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SubjectDtoGender = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
} as const;

export interface SubjectDto {
  /** UID */
  uid: string;
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** 生年月日 */
  dateOfBirth: string;
  /** 性別 */
  gender: SubjectDtoGender;
  /** テナントUID */
  tenantUid: string;
  /** 作成日時 */
  createdAt: string;
}

/**
 * 要介護状態区分
 */
export type AssessmentDtoCareLevel = typeof AssessmentDtoCareLevel[keyof typeof AssessmentDtoCareLevel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssessmentDtoCareLevel = {
  NEEDS_CARE_1: 'NEEDS_CARE_1',
  NEEDS_CARE_2: 'NEEDS_CARE_2',
  NEEDS_CARE_3: 'NEEDS_CARE_3',
  NEEDS_CARE_4: 'NEEDS_CARE_4',
  NEEDS_CARE_5: 'NEEDS_CARE_5',
} as const;

/**
 * 障害高齢者の日常生活自立度判定基準
 */
export type AssessmentDtoPhysicalIndependence = typeof AssessmentDtoPhysicalIndependence[keyof typeof AssessmentDtoPhysicalIndependence];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssessmentDtoPhysicalIndependence = {
  INDEPENDENT: 'INDEPENDENT',
  J1: 'J1',
  J2: 'J2',
  A1: 'A1',
  A2: 'A2',
  B1: 'B1',
  B2: 'B2',
  C1: 'C1',
  C2: 'C2',
} as const;

/**
 * 認知症高齢者の日常生活自立度判定基準
 */
export type AssessmentDtoCognitiveIndependence = typeof AssessmentDtoCognitiveIndependence[keyof typeof AssessmentDtoCognitiveIndependence];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssessmentDtoCognitiveIndependence = {
  INDEPENDENT: 'INDEPENDENT',
  I: 'I',
  IIa: 'IIa',
  IIb: 'IIb',
  IIIa: 'IIIa',
  IIIb: 'IIIb',
  IV: 'IV',
  M: 'M',
} as const;

export interface AssessmentDto {
  /** UID */
  uid: string;
  /** アセスメント対象者UID */
  subjectUid: string;
  /** アセスメント対象者 */
  subject: SubjectDto;
  /** テナントUID */
  tenantUid: string;
  /** 記入者UID */
  userUid: string;
  /** 家族構成 */
  familyInfo: string;
  /** 要介護状態区分 */
  careLevel: AssessmentDtoCareLevel;
  /** 障害高齢者の日常生活自立度判定基準 */
  physicalIndependence: AssessmentDtoPhysicalIndependence;
  /** 認知症高齢者の日常生活自立度判定基準 */
  cognitiveIndependence: AssessmentDtoCognitiveIndependence;
  /** 既往症 */
  medicalHistory: string;
  /** 服用薬剤 */
  medications: string;
  /** 使用しているフォーマルサービス */
  formalServices: string;
  /** 使用しているインフォーマルサービス */
  informalSupport: string;
  /** 相談に至った経緯 */
  consultationBackground: string;
  /** 生活史 */
  lifeHistory: string;
  /** 主訴 */
  complaints: string;
  /** 健康状態 */
  healthNotes: string;
  /** 精神状態 */
  mentalStatus: string;
  /** 身体状態 */
  physicalStatus: string;
  /** ADL */
  adlStatus: string;
  /** コミュニケーション */
  communication: string;
  /** 日常生活 */
  dailyLife: string;
  /** IADL */
  instrumentalADL: string;
  /** 参加・参加制約 */
  participation: string;
  /** 環境 */
  environment: string;
  /** 生活状況 */
  livingSituation: string;
  /** 制度的環境 */
  legalSupport: string;
  /** 個人因子 */
  personalTraits: string;
  /** 作成日時 */
  createdAt: string;
}

export interface AssessmentListResponseDto {
  /** アセスメント一覧 */
  items: AssessmentDto[];
  /** 総件数 */
  total: number;
}

export interface AssessmentCreateInputDto {
  /** アセスメント対象者UID */
  subjectUid: string;
}

/**
 * 要介護状態区分
 */
export type AssessmentUpdateInputDtoCareLevel = typeof AssessmentUpdateInputDtoCareLevel[keyof typeof AssessmentUpdateInputDtoCareLevel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssessmentUpdateInputDtoCareLevel = {
  NEEDS_CARE_1: 'NEEDS_CARE_1',
  NEEDS_CARE_2: 'NEEDS_CARE_2',
  NEEDS_CARE_3: 'NEEDS_CARE_3',
  NEEDS_CARE_4: 'NEEDS_CARE_4',
  NEEDS_CARE_5: 'NEEDS_CARE_5',
} as const;

/**
 * 障害高齢者の日常生活自立度判定基準
 */
export type AssessmentUpdateInputDtoPhysicalIndependence = typeof AssessmentUpdateInputDtoPhysicalIndependence[keyof typeof AssessmentUpdateInputDtoPhysicalIndependence];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssessmentUpdateInputDtoPhysicalIndependence = {
  INDEPENDENT: 'INDEPENDENT',
  J1: 'J1',
  J2: 'J2',
  A1: 'A1',
  A2: 'A2',
  B1: 'B1',
  B2: 'B2',
  C1: 'C1',
  C2: 'C2',
} as const;

/**
 * 認知症高齢者の日常生活自立度判定基準
 */
export type AssessmentUpdateInputDtoCognitiveIndependence = typeof AssessmentUpdateInputDtoCognitiveIndependence[keyof typeof AssessmentUpdateInputDtoCognitiveIndependence];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssessmentUpdateInputDtoCognitiveIndependence = {
  INDEPENDENT: 'INDEPENDENT',
  I: 'I',
  IIa: 'IIa',
  IIb: 'IIb',
  IIIa: 'IIIa',
  IIIb: 'IIIb',
  IV: 'IV',
  M: 'M',
} as const;

export interface AssessmentUpdateInputDto {
  /** 家族構成 */
  familyInfo?: string;
  /** 要介護状態区分 */
  careLevel?: AssessmentUpdateInputDtoCareLevel;
  /** 障害高齢者の日常生活自立度判定基準 */
  physicalIndependence?: AssessmentUpdateInputDtoPhysicalIndependence;
  /** 認知症高齢者の日常生活自立度判定基準 */
  cognitiveIndependence?: AssessmentUpdateInputDtoCognitiveIndependence;
  /** 既往症 */
  medicalHistory?: string;
  /** 服用薬剤 */
  medications?: string;
  /** 使用しているフォーマルサービス */
  formalServices?: string;
  /** 使用しているインフォーマルサービス */
  informalSupport?: string;
  /** 相談に至った経緯 */
  consultationBackground?: string;
  /** 生活史 */
  lifeHistory?: string;
  /** 主訴 */
  complaints?: string;
  /** 健康状態 */
  healthNotes?: string;
  /** 精神状態 */
  mentalStatus?: string;
  /** 身体状態 */
  physicalStatus?: string;
  /** ADL */
  adlStatus?: string;
  /** コミュニケーション */
  communication?: string;
  /** 日常生活 */
  dailyLife?: string;
  /** IADL */
  instrumentalADL?: string;
  /** 参加・参加制約 */
  participation?: string;
  /** 環境 */
  environment?: string;
  /** 生活状況 */
  livingSituation?: string;
  /** 制度的環境 */
  legalSupport?: string;
  /** 個人因子 */
  personalTraits?: string;
}

export interface TranscriptionDto {
  /** 文字起こしテキスト */
  transcription: string;
}

export interface TranscriptionInputDto {
  /** 文字起こしテキスト */
  transcription: string;
}

export interface SubjectListResponseDto {
  /** アセスメント対象者一覧 */
  items: SubjectDto[];
  /** 総件数 */
  total: number;
}

/**
 * 性別
 */
export type SubjectCreateInputDtoGender = typeof SubjectCreateInputDtoGender[keyof typeof SubjectCreateInputDtoGender];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SubjectCreateInputDtoGender = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
} as const;

export interface SubjectCreateInputDto {
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** 生年月日 */
  dateOfBirth: string;
  /** 性別 */
  gender: SubjectCreateInputDtoGender;
}

/**
 * 性別
 */
export type SubjectUpdateInputDtoGender = typeof SubjectUpdateInputDtoGender[keyof typeof SubjectUpdateInputDtoGender];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SubjectUpdateInputDtoGender = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
} as const;

export interface SubjectUpdateInputDto {
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** 生年月日 */
  dateOfBirth: string;
  /** 性別 */
  gender: SubjectUpdateInputDtoGender;
}

export type GetDailyFoodRecordsParams = {
/**
 * 開始日（YYYY-MM-DD形式）。指定しない場合は過去30日間
 */
startDate?: string;
/**
 * 終了日（YYYY-MM-DD形式）。指定しない場合は現在日
 */
endDate?: string;
};





export const appControllerGetHello = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/`, method: 'GET', signal
    },
      );
    }
  

export const getAppControllerGetHelloQueryKey = () => {
    return [`/`] as const;
    }

    
export const getAppControllerGetHelloQueryOptions = <TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppControllerGetHelloQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerGetHello>>> = ({ signal }) => appControllerGetHello(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppControllerGetHelloQueryResult = NonNullable<Awaited<ReturnType<typeof appControllerGetHello>>>
export type AppControllerGetHelloQueryError = unknown


export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAppControllerGetHelloQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary ログイン
 */
export const login = (
    signInDto: SignInDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TokenDto>(
      {url: `/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: signInDto, signal
    },
      );
    }
  


export const getLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: SignInDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: SignInDto}, TContext> => {
    
const mutationKey = ['login'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: SignInDto}> = (props) => {
          const {data} = props ?? {};

          return  login(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = SignInDto
    export type LoginMutationError = unknown

    /**
 * @summary ログイン
 */
export const useLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: SignInDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: SignInDto},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ログイン中のユーザー情報を取得
 */
export const getMe = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserDto>(
      {url: `/auth/me`, method: 'GET', signal
    },
      );
    }
  

export const getGetMeQueryKey = () => {
    return [`/auth/me`] as const;
    }

    
export const getGetMeQueryOptions = <TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMe>>> = ({ signal }) => getMe(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMeQueryResult = NonNullable<Awaited<ReturnType<typeof getMe>>>
export type GetMeQueryError = unknown


export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ログイン中のユーザー情報を取得
 */

export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary テナント内のユーザー一覧を取得
 */
export const getUsers = (
    tenantUid?: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserListResponseDto>(
      {url: `/tenants/${tenantUid}/users`, method: 'GET', signal
    },
      );
    }
  

export const getGetUsersQueryKey = (tenantUid?: string,) => {
    return [`/tenants/${tenantUid}/users`] as const;
    }

    
export const getGetUsersQueryOptions = <TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersQueryKey(tenantUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(tenantUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(tenantUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersQueryError = unknown


export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
 tenantUid: undefined |  string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsers>>,
          TError,
          Awaited<ReturnType<typeof getUsers>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsers>>,
          TError,
          Awaited<ReturnType<typeof getUsers>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary テナント内のユーザー一覧を取得
 */

export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersQueryOptions(tenantUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary テナントにユーザーを作成
 */
export const createUser = (
    tenantUid: string,
    tenantUserCreateInputDto: TenantUserCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserDto>(
      {url: `/tenants/${tenantUid}/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tenantUserCreateInputDto, signal
    },
      );
    }
  


export const getCreateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{tenantUid: string;data: TenantUserCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{tenantUid: string;data: TenantUserCreateInputDto}, TContext> => {
    
const mutationKey = ['createUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {tenantUid: string;data: TenantUserCreateInputDto}> = (props) => {
          const {tenantUid,data} = props ?? {};

          return  createUser(tenantUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = TenantUserCreateInputDto
    export type CreateUserMutationError = unknown

    /**
 * @summary テナントにユーザーを作成
 */
export const useCreateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{tenantUid: string;data: TenantUserCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {tenantUid: string;data: TenantUserCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ユーザーを更新
 */
export const updateUser = (
    uid: string,
    userUpdateInputDto: UserUpdateInputDto,
 ) => {
      
      
      return customInstance<UserDto>(
      {url: `/users/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: userUpdateInputDto
    },
      );
    }
  


export const getUpdateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{uid: string;data: UserUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{uid: string;data: UserUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {uid: string;data: UserUpdateInputDto}> = (props) => {
          const {uid,data} = props ?? {};

          return  updateUser(uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UserUpdateInputDto
    export type UpdateUserMutationError = unknown

    /**
 * @summary ユーザーを更新
 */
export const useUpdateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{uid: string;data: UserUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {uid: string;data: UserUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ユーザーを削除
 */
export const deleteUser = (
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/users/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{uid: string}, TContext> => {
    
const mutationKey = ['deleteUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {uid: string}> = (props) => {
          const {uid} = props ?? {};

          return  deleteUser(uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = unknown

    /**
 * @summary ユーザーを削除
 */
export const useDeleteUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary テナント一覧を取得
 */
export const getTenants = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<TenantListResponseDto>(
      {url: `/tenants`, method: 'GET', signal
    },
      );
    }
  

export const getGetTenantsQueryKey = () => {
    return [`/tenants`] as const;
    }

    
export const getGetTenantsQueryOptions = <TData = Awaited<ReturnType<typeof getTenants>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenants>>> = ({ signal }) => getTenants(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTenantsQueryResult = NonNullable<Awaited<ReturnType<typeof getTenants>>>
export type GetTenantsQueryError = unknown


export function useGetTenants<TData = Awaited<ReturnType<typeof getTenants>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenants>>,
          TError,
          Awaited<ReturnType<typeof getTenants>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenants<TData = Awaited<ReturnType<typeof getTenants>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenants>>,
          TError,
          Awaited<ReturnType<typeof getTenants>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenants<TData = Awaited<ReturnType<typeof getTenants>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary テナント一覧を取得
 */

export function useGetTenants<TData = Awaited<ReturnType<typeof getTenants>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTenantsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary テナントを作成する
 */
export const createTenant = (
    tenantCreateInputDto: TenantCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TenantDto>(
      {url: `/tenants`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tenantCreateInputDto, signal
    },
      );
    }
  


export const getCreateTenantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTenant>>, TError,{data: TenantCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createTenant>>, TError,{data: TenantCreateInputDto}, TContext> => {
    
const mutationKey = ['createTenant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTenant>>, {data: TenantCreateInputDto}> = (props) => {
          const {data} = props ?? {};

          return  createTenant(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTenantMutationResult = NonNullable<Awaited<ReturnType<typeof createTenant>>>
    export type CreateTenantMutationBody = TenantCreateInputDto
    export type CreateTenantMutationError = unknown

    /**
 * @summary テナントを作成する
 */
export const useCreateTenant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTenant>>, TError,{data: TenantCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createTenant>>,
        TError,
        {data: TenantCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateTenantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary テナントの詳細を取得
 */
export const getTenant = (
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TenantDto>(
      {url: `/tenants/${uid}`, method: 'GET', signal
    },
      );
    }
  

export const getGetTenantQueryKey = (uid: string,) => {
    return [`/tenants/${uid}`] as const;
    }

    
export const getGetTenantQueryOptions = <TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantQueryKey(uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenant>>> = ({ signal }) => getTenant(uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTenantQueryResult = NonNullable<Awaited<ReturnType<typeof getTenant>>>
export type GetTenantQueryError = unknown


export function useGetTenant<TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(
 uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenant>>,
          TError,
          Awaited<ReturnType<typeof getTenant>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenant<TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenant>>,
          TError,
          Awaited<ReturnType<typeof getTenant>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenant<TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary テナントの詳細を取得
 */

export function useGetTenant<TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTenantQueryOptions(uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary テナントを更新
 */
export const updateTenant = (
    uid: string,
    tenantUpdateInputDto: TenantUpdateInputDto,
 ) => {
      
      
      return customInstance<TenantDto>(
      {url: `/tenants/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: tenantUpdateInputDto
    },
      );
    }
  


export const getUpdateTenantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTenant>>, TError,{uid: string;data: TenantUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateTenant>>, TError,{uid: string;data: TenantUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateTenant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTenant>>, {uid: string;data: TenantUpdateInputDto}> = (props) => {
          const {uid,data} = props ?? {};

          return  updateTenant(uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTenantMutationResult = NonNullable<Awaited<ReturnType<typeof updateTenant>>>
    export type UpdateTenantMutationBody = TenantUpdateInputDto
    export type UpdateTenantMutationError = unknown

    /**
 * @summary テナントを更新
 */
export const useUpdateTenant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTenant>>, TError,{uid: string;data: TenantUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateTenant>>,
        TError,
        {uid: string;data: TenantUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateTenantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary テナントを削除
 */
export const deleteTenant = (
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/tenants/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteTenantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTenant>>, TError,{uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteTenant>>, TError,{uid: string}, TContext> => {
    
const mutationKey = ['deleteTenant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTenant>>, {uid: string}> = (props) => {
          const {uid} = props ?? {};

          return  deleteTenant(uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTenantMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTenant>>>
    
    export type DeleteTenantMutationError = unknown

    /**
 * @summary テナントを削除
 */
export const useDeleteTenant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTenant>>, TError,{uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteTenant>>,
        TError,
        {uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteTenantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary テナント内の利用者一覧を取得
 */
export const getResidents = (
    tenantUid?: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResidentListResponseDto>(
      {url: `/tenants/${tenantUid}/residents`, method: 'GET', signal
    },
      );
    }
  

export const getGetResidentsQueryKey = (tenantUid?: string,) => {
    return [`/tenants/${tenantUid}/residents`] as const;
    }

    
export const getGetResidentsQueryOptions = <TData = Awaited<ReturnType<typeof getResidents>>, TError = unknown>(tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetResidentsQueryKey(tenantUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getResidents>>> = ({ signal }) => getResidents(tenantUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(tenantUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetResidentsQueryResult = NonNullable<Awaited<ReturnType<typeof getResidents>>>
export type GetResidentsQueryError = unknown


export function useGetResidents<TData = Awaited<ReturnType<typeof getResidents>>, TError = unknown>(
 tenantUid: undefined |  string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResidents>>,
          TError,
          Awaited<ReturnType<typeof getResidents>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResidents<TData = Awaited<ReturnType<typeof getResidents>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResidents>>,
          TError,
          Awaited<ReturnType<typeof getResidents>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResidents<TData = Awaited<ReturnType<typeof getResidents>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary テナント内の利用者一覧を取得
 */

export function useGetResidents<TData = Awaited<ReturnType<typeof getResidents>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetResidentsQueryOptions(tenantUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary テナントに利用者を作成
 */
export const createResident = (
    tenantUid: string,
    residentCreateInputDto: ResidentCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResidentDto>(
      {url: `/tenants/${tenantUid}/residents`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: residentCreateInputDto, signal
    },
      );
    }
  


export const getCreateResidentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createResident>>, TError,{tenantUid: string;data: ResidentCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createResident>>, TError,{tenantUid: string;data: ResidentCreateInputDto}, TContext> => {
    
const mutationKey = ['createResident'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createResident>>, {tenantUid: string;data: ResidentCreateInputDto}> = (props) => {
          const {tenantUid,data} = props ?? {};

          return  createResident(tenantUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateResidentMutationResult = NonNullable<Awaited<ReturnType<typeof createResident>>>
    export type CreateResidentMutationBody = ResidentCreateInputDto
    export type CreateResidentMutationError = unknown

    /**
 * @summary テナントに利用者を作成
 */
export const useCreateResident = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createResident>>, TError,{tenantUid: string;data: ResidentCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createResident>>,
        TError,
        {tenantUid: string;data: ResidentCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateResidentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の詳細を取得
 */
export const getResident = (
    tenantUid: string,
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResidentDto>(
      {url: `/tenants/${tenantUid}/residents/${uid}`, method: 'GET', signal
    },
      );
    }
  

export const getGetResidentQueryKey = (tenantUid: string,
    uid: string,) => {
    return [`/tenants/${tenantUid}/residents/${uid}`] as const;
    }

    
export const getGetResidentQueryOptions = <TData = Awaited<ReturnType<typeof getResident>>, TError = unknown>(tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetResidentQueryKey(tenantUid,uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getResident>>> = ({ signal }) => getResident(tenantUid,uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(tenantUid && uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetResidentQueryResult = NonNullable<Awaited<ReturnType<typeof getResident>>>
export type GetResidentQueryError = unknown


export function useGetResident<TData = Awaited<ReturnType<typeof getResident>>, TError = unknown>(
 tenantUid: string,
    uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResident>>,
          TError,
          Awaited<ReturnType<typeof getResident>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResident<TData = Awaited<ReturnType<typeof getResident>>, TError = unknown>(
 tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResident>>,
          TError,
          Awaited<ReturnType<typeof getResident>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResident<TData = Awaited<ReturnType<typeof getResident>>, TError = unknown>(
 tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の詳細を取得
 */

export function useGetResident<TData = Awaited<ReturnType<typeof getResident>>, TError = unknown>(
 tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetResidentQueryOptions(tenantUid,uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 利用者を更新
 */
export const updateResident = (
    tenantUid: string,
    uid: string,
    residentUpdateInputDto: ResidentUpdateInputDto,
 ) => {
      
      
      return customInstance<ResidentDto>(
      {url: `/tenants/${tenantUid}/residents/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: residentUpdateInputDto
    },
      );
    }
  


export const getUpdateResidentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateResident>>, TError,{tenantUid: string;uid: string;data: ResidentUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateResident>>, TError,{tenantUid: string;uid: string;data: ResidentUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateResident'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateResident>>, {tenantUid: string;uid: string;data: ResidentUpdateInputDto}> = (props) => {
          const {tenantUid,uid,data} = props ?? {};

          return  updateResident(tenantUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateResidentMutationResult = NonNullable<Awaited<ReturnType<typeof updateResident>>>
    export type UpdateResidentMutationBody = ResidentUpdateInputDto
    export type UpdateResidentMutationError = unknown

    /**
 * @summary 利用者を更新
 */
export const useUpdateResident = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateResident>>, TError,{tenantUid: string;uid: string;data: ResidentUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateResident>>,
        TError,
        {tenantUid: string;uid: string;data: ResidentUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateResidentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者を削除
 */
export const deleteResident = (
    tenantUid: string,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/tenants/${tenantUid}/residents/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteResidentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteResident>>, TError,{tenantUid: string;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteResident>>, TError,{tenantUid: string;uid: string}, TContext> => {
    
const mutationKey = ['deleteResident'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteResident>>, {tenantUid: string;uid: string}> = (props) => {
          const {tenantUid,uid} = props ?? {};

          return  deleteResident(tenantUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteResidentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteResident>>>
    
    export type DeleteResidentMutationError = unknown

    /**
 * @summary 利用者を削除
 */
export const useDeleteResident = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteResident>>, TError,{tenantUid: string;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteResident>>,
        TError,
        {tenantUid: string;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteResidentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の食事記録一覧を取得
 */
export const getFoodRecords = (
    residentUid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<FoodRecordListResponseDto>(
      {url: `/residents/${residentUid}/food-records`, method: 'GET', signal
    },
      );
    }
  

export const getGetFoodRecordsQueryKey = (residentUid: string,) => {
    return [`/residents/${residentUid}/food-records`] as const;
    }

    
export const getGetFoodRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getFoodRecords>>, TError = unknown>(residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFoodRecordsQueryKey(residentUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFoodRecords>>> = ({ signal }) => getFoodRecords(residentUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFoodRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getFoodRecords>>>
export type GetFoodRecordsQueryError = unknown


export function useGetFoodRecords<TData = Awaited<ReturnType<typeof getFoodRecords>>, TError = unknown>(
 residentUid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFoodRecords>>,
          TError,
          Awaited<ReturnType<typeof getFoodRecords>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoodRecords<TData = Awaited<ReturnType<typeof getFoodRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFoodRecords>>,
          TError,
          Awaited<ReturnType<typeof getFoodRecords>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoodRecords<TData = Awaited<ReturnType<typeof getFoodRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の食事記録一覧を取得
 */

export function useGetFoodRecords<TData = Awaited<ReturnType<typeof getFoodRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFoodRecordsQueryOptions(residentUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 食事記録を作成
 */
export const createFoodRecord = (
    residentUid: string,
    foodRecordCreateInputDto: FoodRecordCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<FoodRecordDto>(
      {url: `/residents/${residentUid}/food-records`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: foodRecordCreateInputDto, signal
    },
      );
    }
  


export const getCreateFoodRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFoodRecord>>, TError,{residentUid: string;data: FoodRecordCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createFoodRecord>>, TError,{residentUid: string;data: FoodRecordCreateInputDto}, TContext> => {
    
const mutationKey = ['createFoodRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createFoodRecord>>, {residentUid: string;data: FoodRecordCreateInputDto}> = (props) => {
          const {residentUid,data} = props ?? {};

          return  createFoodRecord(residentUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateFoodRecordMutationResult = NonNullable<Awaited<ReturnType<typeof createFoodRecord>>>
    export type CreateFoodRecordMutationBody = FoodRecordCreateInputDto
    export type CreateFoodRecordMutationError = unknown

    /**
 * @summary 食事記録を作成
 */
export const useCreateFoodRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFoodRecord>>, TError,{residentUid: string;data: FoodRecordCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createFoodRecord>>,
        TError,
        {residentUid: string;data: FoodRecordCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateFoodRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の日別食事記録一覧を取得
 */
export const getDailyFoodRecords = (
    residentUid: string,
    params?: GetDailyFoodRecordsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<DailyFoodRecordsListResponseDto>(
      {url: `/residents/${residentUid}/food-records/daily`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetDailyFoodRecordsQueryKey = (residentUid: string,
    params?: GetDailyFoodRecordsParams,) => {
    return [`/residents/${residentUid}/food-records/daily`, ...(params ? [params]: [])] as const;
    }

    
export const getGetDailyFoodRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getDailyFoodRecords>>, TError = unknown>(residentUid: string,
    params?: GetDailyFoodRecordsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyFoodRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDailyFoodRecordsQueryKey(residentUid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDailyFoodRecords>>> = ({ signal }) => getDailyFoodRecords(residentUid,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDailyFoodRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDailyFoodRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getDailyFoodRecords>>>
export type GetDailyFoodRecordsQueryError = unknown


export function useGetDailyFoodRecords<TData = Awaited<ReturnType<typeof getDailyFoodRecords>>, TError = unknown>(
 residentUid: string,
    params: undefined |  GetDailyFoodRecordsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyFoodRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDailyFoodRecords>>,
          TError,
          Awaited<ReturnType<typeof getDailyFoodRecords>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDailyFoodRecords<TData = Awaited<ReturnType<typeof getDailyFoodRecords>>, TError = unknown>(
 residentUid: string,
    params?: GetDailyFoodRecordsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyFoodRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDailyFoodRecords>>,
          TError,
          Awaited<ReturnType<typeof getDailyFoodRecords>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDailyFoodRecords<TData = Awaited<ReturnType<typeof getDailyFoodRecords>>, TError = unknown>(
 residentUid: string,
    params?: GetDailyFoodRecordsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyFoodRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の日別食事記録一覧を取得
 */

export function useGetDailyFoodRecords<TData = Awaited<ReturnType<typeof getDailyFoodRecords>>, TError = unknown>(
 residentUid: string,
    params?: GetDailyFoodRecordsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyFoodRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDailyFoodRecordsQueryOptions(residentUid,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 食事記録を更新
 */
export const updateFoodRecord = (
    residentUid: unknown,
    uid: string,
    foodRecordUpdateInputDto: FoodRecordUpdateInputDto,
 ) => {
      
      
      return customInstance<FoodRecordDto>(
      {url: `/residents/${residentUid}/food-records/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: foodRecordUpdateInputDto
    },
      );
    }
  


export const getUpdateFoodRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFoodRecord>>, TError,{residentUid: unknown;uid: string;data: FoodRecordUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateFoodRecord>>, TError,{residentUid: unknown;uid: string;data: FoodRecordUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateFoodRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateFoodRecord>>, {residentUid: unknown;uid: string;data: FoodRecordUpdateInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateFoodRecord(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateFoodRecordMutationResult = NonNullable<Awaited<ReturnType<typeof updateFoodRecord>>>
    export type UpdateFoodRecordMutationBody = FoodRecordUpdateInputDto
    export type UpdateFoodRecordMutationError = unknown

    /**
 * @summary 食事記録を更新
 */
export const useUpdateFoodRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFoodRecord>>, TError,{residentUid: unknown;uid: string;data: FoodRecordUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateFoodRecord>>,
        TError,
        {residentUid: unknown;uid: string;data: FoodRecordUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateFoodRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 食事記録を削除
 */
export const deleteFoodRecord = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/food-records/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteFoodRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteFoodRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteFoodRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteFoodRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteFoodRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteFoodRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteFoodRecordMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFoodRecord>>>
    
    export type DeleteFoodRecordMutationError = unknown

    /**
 * @summary 食事記録を削除
 */
export const useDeleteFoodRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteFoodRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteFoodRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteFoodRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の入浴記録一覧を取得
 */
export const getBathRecords = (
    residentUid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BathRecordListResponseDto>(
      {url: `/residents/${residentUid}/bath-records`, method: 'GET', signal
    },
      );
    }
  

export const getGetBathRecordsQueryKey = (residentUid: string,) => {
    return [`/residents/${residentUid}/bath-records`] as const;
    }

    
export const getGetBathRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getBathRecords>>, TError = unknown>(residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBathRecordsQueryKey(residentUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBathRecords>>> = ({ signal }) => getBathRecords(residentUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBathRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getBathRecords>>>
export type GetBathRecordsQueryError = unknown


export function useGetBathRecords<TData = Awaited<ReturnType<typeof getBathRecords>>, TError = unknown>(
 residentUid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBathRecords>>,
          TError,
          Awaited<ReturnType<typeof getBathRecords>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBathRecords<TData = Awaited<ReturnType<typeof getBathRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBathRecords>>,
          TError,
          Awaited<ReturnType<typeof getBathRecords>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBathRecords<TData = Awaited<ReturnType<typeof getBathRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の入浴記録一覧を取得
 */

export function useGetBathRecords<TData = Awaited<ReturnType<typeof getBathRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBathRecordsQueryOptions(residentUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 入浴記録を作成
 */
export const createBathRecord = (
    residentUid: string,
    bathRecordCreateInputDto: BathRecordCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BathRecordDto>(
      {url: `/residents/${residentUid}/bath-records`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bathRecordCreateInputDto, signal
    },
      );
    }
  


export const getCreateBathRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBathRecord>>, TError,{residentUid: string;data: BathRecordCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createBathRecord>>, TError,{residentUid: string;data: BathRecordCreateInputDto}, TContext> => {
    
const mutationKey = ['createBathRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBathRecord>>, {residentUid: string;data: BathRecordCreateInputDto}> = (props) => {
          const {residentUid,data} = props ?? {};

          return  createBathRecord(residentUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBathRecordMutationResult = NonNullable<Awaited<ReturnType<typeof createBathRecord>>>
    export type CreateBathRecordMutationBody = BathRecordCreateInputDto
    export type CreateBathRecordMutationError = unknown

    /**
 * @summary 入浴記録を作成
 */
export const useCreateBathRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBathRecord>>, TError,{residentUid: string;data: BathRecordCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createBathRecord>>,
        TError,
        {residentUid: string;data: BathRecordCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateBathRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 入浴記録を更新
 */
export const updateBathRecord = (
    residentUid: unknown,
    uid: string,
    bathRecordUpdateInputDto: BathRecordUpdateInputDto,
 ) => {
      
      
      return customInstance<BathRecordDto>(
      {url: `/residents/${residentUid}/bath-records/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: bathRecordUpdateInputDto
    },
      );
    }
  


export const getUpdateBathRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBathRecord>>, TError,{residentUid: unknown;uid: string;data: BathRecordUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBathRecord>>, TError,{residentUid: unknown;uid: string;data: BathRecordUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateBathRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBathRecord>>, {residentUid: unknown;uid: string;data: BathRecordUpdateInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateBathRecord(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBathRecordMutationResult = NonNullable<Awaited<ReturnType<typeof updateBathRecord>>>
    export type UpdateBathRecordMutationBody = BathRecordUpdateInputDto
    export type UpdateBathRecordMutationError = unknown

    /**
 * @summary 入浴記録を更新
 */
export const useUpdateBathRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBathRecord>>, TError,{residentUid: unknown;uid: string;data: BathRecordUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateBathRecord>>,
        TError,
        {residentUid: unknown;uid: string;data: BathRecordUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateBathRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 入浴記録を削除
 */
export const deleteBathRecord = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/bath-records/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBathRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBathRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteBathRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteBathRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBathRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteBathRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBathRecordMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBathRecord>>>
    
    export type DeleteBathRecordMutationError = unknown

    /**
 * @summary 入浴記録を削除
 */
export const useDeleteBathRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBathRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteBathRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteBathRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の排泄記録一覧を取得
 */
export const getEliminationRecords = (
    residentUid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<EliminationRecordListResponseDto>(
      {url: `/residents/${residentUid}/elimination-records`, method: 'GET', signal
    },
      );
    }
  

export const getGetEliminationRecordsQueryKey = (residentUid: string,) => {
    return [`/residents/${residentUid}/elimination-records`] as const;
    }

    
export const getGetEliminationRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getEliminationRecords>>, TError = unknown>(residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEliminationRecordsQueryKey(residentUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEliminationRecords>>> = ({ signal }) => getEliminationRecords(residentUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEliminationRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getEliminationRecords>>>
export type GetEliminationRecordsQueryError = unknown


export function useGetEliminationRecords<TData = Awaited<ReturnType<typeof getEliminationRecords>>, TError = unknown>(
 residentUid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEliminationRecords>>,
          TError,
          Awaited<ReturnType<typeof getEliminationRecords>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEliminationRecords<TData = Awaited<ReturnType<typeof getEliminationRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEliminationRecords>>,
          TError,
          Awaited<ReturnType<typeof getEliminationRecords>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEliminationRecords<TData = Awaited<ReturnType<typeof getEliminationRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の排泄記録一覧を取得
 */

export function useGetEliminationRecords<TData = Awaited<ReturnType<typeof getEliminationRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEliminationRecordsQueryOptions(residentUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 排泄記録を作成
 */
export const createEliminationRecord = (
    residentUid: string,
    eliminationRecordCreateInputDto: EliminationRecordCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<EliminationRecordDto>(
      {url: `/residents/${residentUid}/elimination-records`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: eliminationRecordCreateInputDto, signal
    },
      );
    }
  


export const getCreateEliminationRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEliminationRecord>>, TError,{residentUid: string;data: EliminationRecordCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createEliminationRecord>>, TError,{residentUid: string;data: EliminationRecordCreateInputDto}, TContext> => {
    
const mutationKey = ['createEliminationRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createEliminationRecord>>, {residentUid: string;data: EliminationRecordCreateInputDto}> = (props) => {
          const {residentUid,data} = props ?? {};

          return  createEliminationRecord(residentUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateEliminationRecordMutationResult = NonNullable<Awaited<ReturnType<typeof createEliminationRecord>>>
    export type CreateEliminationRecordMutationBody = EliminationRecordCreateInputDto
    export type CreateEliminationRecordMutationError = unknown

    /**
 * @summary 排泄記録を作成
 */
export const useCreateEliminationRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEliminationRecord>>, TError,{residentUid: string;data: EliminationRecordCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createEliminationRecord>>,
        TError,
        {residentUid: string;data: EliminationRecordCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateEliminationRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 排泄記録を更新
 */
export const updateEliminationRecord = (
    residentUid: unknown,
    uid: string,
    eliminationRecordUpdateInputDto: EliminationRecordUpdateInputDto,
 ) => {
      
      
      return customInstance<EliminationRecordDto>(
      {url: `/residents/${residentUid}/elimination-records/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: eliminationRecordUpdateInputDto
    },
      );
    }
  


export const getUpdateEliminationRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEliminationRecord>>, TError,{residentUid: unknown;uid: string;data: EliminationRecordUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateEliminationRecord>>, TError,{residentUid: unknown;uid: string;data: EliminationRecordUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateEliminationRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEliminationRecord>>, {residentUid: unknown;uid: string;data: EliminationRecordUpdateInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateEliminationRecord(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateEliminationRecordMutationResult = NonNullable<Awaited<ReturnType<typeof updateEliminationRecord>>>
    export type UpdateEliminationRecordMutationBody = EliminationRecordUpdateInputDto
    export type UpdateEliminationRecordMutationError = unknown

    /**
 * @summary 排泄記録を更新
 */
export const useUpdateEliminationRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEliminationRecord>>, TError,{residentUid: unknown;uid: string;data: EliminationRecordUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateEliminationRecord>>,
        TError,
        {residentUid: unknown;uid: string;data: EliminationRecordUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateEliminationRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 排泄記録を削除
 */
export const deleteEliminationRecord = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/elimination-records/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteEliminationRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEliminationRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteEliminationRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteEliminationRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEliminationRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteEliminationRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteEliminationRecordMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEliminationRecord>>>
    
    export type DeleteEliminationRecordMutationError = unknown

    /**
 * @summary 排泄記録を削除
 */
export const useDeleteEliminationRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEliminationRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteEliminationRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteEliminationRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の日常記録一覧を取得
 */
export const getDailyRecords = (
    residentUid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<DailyRecordListResponseDto>(
      {url: `/residents/${residentUid}/daily-records`, method: 'GET', signal
    },
      );
    }
  

export const getGetDailyRecordsQueryKey = (residentUid: string,) => {
    return [`/residents/${residentUid}/daily-records`] as const;
    }

    
export const getGetDailyRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getDailyRecords>>, TError = unknown>(residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDailyRecordsQueryKey(residentUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDailyRecords>>> = ({ signal }) => getDailyRecords(residentUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDailyRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getDailyRecords>>>
export type GetDailyRecordsQueryError = unknown


export function useGetDailyRecords<TData = Awaited<ReturnType<typeof getDailyRecords>>, TError = unknown>(
 residentUid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDailyRecords>>,
          TError,
          Awaited<ReturnType<typeof getDailyRecords>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDailyRecords<TData = Awaited<ReturnType<typeof getDailyRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDailyRecords>>,
          TError,
          Awaited<ReturnType<typeof getDailyRecords>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDailyRecords<TData = Awaited<ReturnType<typeof getDailyRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の日常記録一覧を取得
 */

export function useGetDailyRecords<TData = Awaited<ReturnType<typeof getDailyRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDailyRecordsQueryOptions(residentUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 日常記録を作成
 */
export const createDailyRecord = (
    residentUid: string,
    dailyRecordCreateInputDto: DailyRecordCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<DailyRecordDto>(
      {url: `/residents/${residentUid}/daily-records`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: dailyRecordCreateInputDto, signal
    },
      );
    }
  


export const getCreateDailyRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDailyRecord>>, TError,{residentUid: string;data: DailyRecordCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createDailyRecord>>, TError,{residentUid: string;data: DailyRecordCreateInputDto}, TContext> => {
    
const mutationKey = ['createDailyRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDailyRecord>>, {residentUid: string;data: DailyRecordCreateInputDto}> = (props) => {
          const {residentUid,data} = props ?? {};

          return  createDailyRecord(residentUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDailyRecordMutationResult = NonNullable<Awaited<ReturnType<typeof createDailyRecord>>>
    export type CreateDailyRecordMutationBody = DailyRecordCreateInputDto
    export type CreateDailyRecordMutationError = unknown

    /**
 * @summary 日常記録を作成
 */
export const useCreateDailyRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDailyRecord>>, TError,{residentUid: string;data: DailyRecordCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createDailyRecord>>,
        TError,
        {residentUid: string;data: DailyRecordCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateDailyRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 日常記録を更新
 */
export const updateDailyRecord = (
    residentUid: unknown,
    uid: string,
    dailyRecordUpdateInputDto: DailyRecordUpdateInputDto,
 ) => {
      
      
      return customInstance<DailyRecordDto>(
      {url: `/residents/${residentUid}/daily-records/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: dailyRecordUpdateInputDto
    },
      );
    }
  


export const getUpdateDailyRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDailyRecord>>, TError,{residentUid: unknown;uid: string;data: DailyRecordUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateDailyRecord>>, TError,{residentUid: unknown;uid: string;data: DailyRecordUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateDailyRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDailyRecord>>, {residentUid: unknown;uid: string;data: DailyRecordUpdateInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateDailyRecord(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDailyRecordMutationResult = NonNullable<Awaited<ReturnType<typeof updateDailyRecord>>>
    export type UpdateDailyRecordMutationBody = DailyRecordUpdateInputDto
    export type UpdateDailyRecordMutationError = unknown

    /**
 * @summary 日常記録を更新
 */
export const useUpdateDailyRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDailyRecord>>, TError,{residentUid: unknown;uid: string;data: DailyRecordUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateDailyRecord>>,
        TError,
        {residentUid: unknown;uid: string;data: DailyRecordUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateDailyRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 日常記録を削除
 */
export const deleteDailyRecord = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/daily-records/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteDailyRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDailyRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteDailyRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteDailyRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDailyRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteDailyRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDailyRecordMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDailyRecord>>>
    
    export type DeleteDailyRecordMutationError = unknown

    /**
 * @summary 日常記録を削除
 */
export const useDeleteDailyRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDailyRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteDailyRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteDailyRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の飲料記録一覧を取得
 */
export const getBeverageRecords = (
    residentUid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BeverageRecordListResponseDto>(
      {url: `/residents/${residentUid}/beverage-records`, method: 'GET', signal
    },
      );
    }
  

export const getGetBeverageRecordsQueryKey = (residentUid: string,) => {
    return [`/residents/${residentUid}/beverage-records`] as const;
    }

    
export const getGetBeverageRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getBeverageRecords>>, TError = unknown>(residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBeverageRecordsQueryKey(residentUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBeverageRecords>>> = ({ signal }) => getBeverageRecords(residentUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBeverageRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getBeverageRecords>>>
export type GetBeverageRecordsQueryError = unknown


export function useGetBeverageRecords<TData = Awaited<ReturnType<typeof getBeverageRecords>>, TError = unknown>(
 residentUid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBeverageRecords>>,
          TError,
          Awaited<ReturnType<typeof getBeverageRecords>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBeverageRecords<TData = Awaited<ReturnType<typeof getBeverageRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBeverageRecords>>,
          TError,
          Awaited<ReturnType<typeof getBeverageRecords>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBeverageRecords<TData = Awaited<ReturnType<typeof getBeverageRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の飲料記録一覧を取得
 */

export function useGetBeverageRecords<TData = Awaited<ReturnType<typeof getBeverageRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBeverageRecordsQueryOptions(residentUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 飲料記録を作成
 */
export const createBeverageRecord = (
    residentUid: string,
    beverageRecordCreateInputDto: BeverageRecordCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BeverageRecordDto>(
      {url: `/residents/${residentUid}/beverage-records`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: beverageRecordCreateInputDto, signal
    },
      );
    }
  


export const getCreateBeverageRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBeverageRecord>>, TError,{residentUid: string;data: BeverageRecordCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createBeverageRecord>>, TError,{residentUid: string;data: BeverageRecordCreateInputDto}, TContext> => {
    
const mutationKey = ['createBeverageRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBeverageRecord>>, {residentUid: string;data: BeverageRecordCreateInputDto}> = (props) => {
          const {residentUid,data} = props ?? {};

          return  createBeverageRecord(residentUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBeverageRecordMutationResult = NonNullable<Awaited<ReturnType<typeof createBeverageRecord>>>
    export type CreateBeverageRecordMutationBody = BeverageRecordCreateInputDto
    export type CreateBeverageRecordMutationError = unknown

    /**
 * @summary 飲料記録を作成
 */
export const useCreateBeverageRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBeverageRecord>>, TError,{residentUid: string;data: BeverageRecordCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createBeverageRecord>>,
        TError,
        {residentUid: string;data: BeverageRecordCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateBeverageRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 飲料記録を更新
 */
export const updateBeverageRecord = (
    residentUid: unknown,
    uid: string,
    beverageRecordUpdateInputDto: BeverageRecordUpdateInputDto,
 ) => {
      
      
      return customInstance<BeverageRecordDto>(
      {url: `/residents/${residentUid}/beverage-records/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: beverageRecordUpdateInputDto
    },
      );
    }
  


export const getUpdateBeverageRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBeverageRecord>>, TError,{residentUid: unknown;uid: string;data: BeverageRecordUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBeverageRecord>>, TError,{residentUid: unknown;uid: string;data: BeverageRecordUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateBeverageRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBeverageRecord>>, {residentUid: unknown;uid: string;data: BeverageRecordUpdateInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateBeverageRecord(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBeverageRecordMutationResult = NonNullable<Awaited<ReturnType<typeof updateBeverageRecord>>>
    export type UpdateBeverageRecordMutationBody = BeverageRecordUpdateInputDto
    export type UpdateBeverageRecordMutationError = unknown

    /**
 * @summary 飲料記録を更新
 */
export const useUpdateBeverageRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBeverageRecord>>, TError,{residentUid: unknown;uid: string;data: BeverageRecordUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateBeverageRecord>>,
        TError,
        {residentUid: unknown;uid: string;data: BeverageRecordUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateBeverageRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 飲料記録を削除
 */
export const deleteBeverageRecord = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/beverage-records/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBeverageRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBeverageRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteBeverageRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteBeverageRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBeverageRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteBeverageRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBeverageRecordMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBeverageRecord>>>
    
    export type DeleteBeverageRecordMutationError = unknown

    /**
 * @summary 飲料記録を削除
 */
export const useDeleteBeverageRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBeverageRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteBeverageRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteBeverageRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アセスメント一覧を取得
 */
export const getAssessments = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<AssessmentListResponseDto>(
      {url: `/assessments`, method: 'GET', signal
    },
      );
    }
  

export const getGetAssessmentsQueryKey = () => {
    return [`/assessments`] as const;
    }

    
export const getGetAssessmentsQueryOptions = <TData = Awaited<ReturnType<typeof getAssessments>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessmentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessments>>> = ({ signal }) => getAssessments(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAssessmentsQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessments>>>
export type GetAssessmentsQueryError = unknown


export function useGetAssessments<TData = Awaited<ReturnType<typeof getAssessments>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssessments>>,
          TError,
          Awaited<ReturnType<typeof getAssessments>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAssessments<TData = Awaited<ReturnType<typeof getAssessments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssessments>>,
          TError,
          Awaited<ReturnType<typeof getAssessments>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAssessments<TData = Awaited<ReturnType<typeof getAssessments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessments>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary アセスメント一覧を取得
 */

export function useGetAssessments<TData = Awaited<ReturnType<typeof getAssessments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessments>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAssessmentsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary アセスメントを作成
 */
export const createAssessment = (
    assessmentCreateInputDto: AssessmentCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AssessmentDto>(
      {url: `/assessments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: assessmentCreateInputDto, signal
    },
      );
    }
  


export const getCreateAssessmentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAssessment>>, TError,{data: AssessmentCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAssessment>>, TError,{data: AssessmentCreateInputDto}, TContext> => {
    
const mutationKey = ['createAssessment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAssessment>>, {data: AssessmentCreateInputDto}> = (props) => {
          const {data} = props ?? {};

          return  createAssessment(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAssessmentMutationResult = NonNullable<Awaited<ReturnType<typeof createAssessment>>>
    export type CreateAssessmentMutationBody = AssessmentCreateInputDto
    export type CreateAssessmentMutationError = unknown

    /**
 * @summary アセスメントを作成
 */
export const useCreateAssessment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAssessment>>, TError,{data: AssessmentCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createAssessment>>,
        TError,
        {data: AssessmentCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateAssessmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アセスメントの詳細を取得
 */
export const getAssessment = (
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AssessmentDto>(
      {url: `/assessments/${uid}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAssessmentQueryKey = (uid: string,) => {
    return [`/assessments/${uid}`] as const;
    }

    
export const getGetAssessmentQueryOptions = <TData = Awaited<ReturnType<typeof getAssessment>>, TError = unknown>(uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessment>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessmentQueryKey(uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessment>>> = ({ signal }) => getAssessment(uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAssessmentQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessment>>>
export type GetAssessmentQueryError = unknown


export function useGetAssessment<TData = Awaited<ReturnType<typeof getAssessment>>, TError = unknown>(
 uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessment>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssessment>>,
          TError,
          Awaited<ReturnType<typeof getAssessment>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAssessment<TData = Awaited<ReturnType<typeof getAssessment>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessment>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssessment>>,
          TError,
          Awaited<ReturnType<typeof getAssessment>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAssessment<TData = Awaited<ReturnType<typeof getAssessment>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessment>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary アセスメントの詳細を取得
 */

export function useGetAssessment<TData = Awaited<ReturnType<typeof getAssessment>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessment>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAssessmentQueryOptions(uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary アセスメントを更新
 */
export const updateAssessment = (
    uid: string,
    assessmentUpdateInputDto: AssessmentUpdateInputDto,
 ) => {
      
      
      return customInstance<AssessmentDto>(
      {url: `/assessments/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: assessmentUpdateInputDto
    },
      );
    }
  


export const getUpdateAssessmentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAssessment>>, TError,{uid: string;data: AssessmentUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAssessment>>, TError,{uid: string;data: AssessmentUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateAssessment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAssessment>>, {uid: string;data: AssessmentUpdateInputDto}> = (props) => {
          const {uid,data} = props ?? {};

          return  updateAssessment(uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAssessmentMutationResult = NonNullable<Awaited<ReturnType<typeof updateAssessment>>>
    export type UpdateAssessmentMutationBody = AssessmentUpdateInputDto
    export type UpdateAssessmentMutationError = unknown

    /**
 * @summary アセスメントを更新
 */
export const useUpdateAssessment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAssessment>>, TError,{uid: string;data: AssessmentUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateAssessment>>,
        TError,
        {uid: string;data: AssessmentUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateAssessmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アセスメントを削除
 */
export const deleteAssessment = (
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/assessments/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAssessmentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssessment>>, TError,{uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAssessment>>, TError,{uid: string}, TContext> => {
    
const mutationKey = ['deleteAssessment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAssessment>>, {uid: string}> = (props) => {
          const {uid} = props ?? {};

          return  deleteAssessment(uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAssessmentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAssessment>>>
    
    export type DeleteAssessmentMutationError = unknown

    /**
 * @summary アセスメントを削除
 */
export const useDeleteAssessment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssessment>>, TError,{uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteAssessment>>,
        TError,
        {uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteAssessmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アセスメントの文字起こしを取得
 */
export const getTranscription = (
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/assessments/${uid}/transcription`, method: 'GET', signal
    },
      );
    }
  

export const getGetTranscriptionQueryKey = (uid: string,) => {
    return [`/assessments/${uid}/transcription`] as const;
    }

    
export const getGetTranscriptionQueryOptions = <TData = Awaited<ReturnType<typeof getTranscription>>, TError = unknown>(uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTranscriptionQueryKey(uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTranscription>>> = ({ signal }) => getTranscription(uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTranscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof getTranscription>>>
export type GetTranscriptionQueryError = unknown


export function useGetTranscription<TData = Awaited<ReturnType<typeof getTranscription>>, TError = unknown>(
 uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTranscription>>,
          TError,
          Awaited<ReturnType<typeof getTranscription>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTranscription<TData = Awaited<ReturnType<typeof getTranscription>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTranscription>>,
          TError,
          Awaited<ReturnType<typeof getTranscription>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTranscription<TData = Awaited<ReturnType<typeof getTranscription>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary アセスメントの文字起こしを取得
 */

export function useGetTranscription<TData = Awaited<ReturnType<typeof getTranscription>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTranscriptionQueryOptions(uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary アセスメントの文字起こしを追記
 */
export const appendTranscription = (
    uid: string,
    transcriptionInputDto: TranscriptionInputDto,
 ) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/assessments/${uid}/transcription`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: transcriptionInputDto
    },
      );
    }
  


export const getAppendTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appendTranscription>>, TError,{uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appendTranscription>>, TError,{uid: string;data: TranscriptionInputDto}, TContext> => {
    
const mutationKey = ['appendTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appendTranscription>>, {uid: string;data: TranscriptionInputDto}> = (props) => {
          const {uid,data} = props ?? {};

          return  appendTranscription(uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppendTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof appendTranscription>>>
    export type AppendTranscriptionMutationBody = TranscriptionInputDto
    export type AppendTranscriptionMutationError = unknown

    /**
 * @summary アセスメントの文字起こしを追記
 */
export const useAppendTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appendTranscription>>, TError,{uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof appendTranscription>>,
        TError,
        {uid: string;data: TranscriptionInputDto},
        TContext
      > => {

      const mutationOptions = getAppendTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アセスメントの文字起こしを置換
 */
export const updateTranscription = (
    uid: string,
    transcriptionInputDto: TranscriptionInputDto,
 ) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/assessments/${uid}/transcription`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: transcriptionInputDto
    },
      );
    }
  


export const getUpdateTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTranscription>>, TError,{uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateTranscription>>, TError,{uid: string;data: TranscriptionInputDto}, TContext> => {
    
const mutationKey = ['updateTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTranscription>>, {uid: string;data: TranscriptionInputDto}> = (props) => {
          const {uid,data} = props ?? {};

          return  updateTranscription(uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof updateTranscription>>>
    export type UpdateTranscriptionMutationBody = TranscriptionInputDto
    export type UpdateTranscriptionMutationError = unknown

    /**
 * @summary アセスメントの文字起こしを置換
 */
export const useUpdateTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTranscription>>, TError,{uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateTranscription>>,
        TError,
        {uid: string;data: TranscriptionInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アセスメントの文字起こしを削除
 */
export const deleteTranscription = (
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/assessments/${uid}/transcription`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTranscription>>, TError,{uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteTranscription>>, TError,{uid: string}, TContext> => {
    
const mutationKey = ['deleteTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTranscription>>, {uid: string}> = (props) => {
          const {uid} = props ?? {};

          return  deleteTranscription(uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTranscription>>>
    
    export type DeleteTranscriptionMutationError = unknown

    /**
 * @summary アセスメントの文字起こしを削除
 */
export const useDeleteTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTranscription>>, TError,{uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteTranscription>>,
        TError,
        {uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アセスメントの要約を作成
 */
export const summarizeAssessment = (
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/assessments/${uid}/summarize`, method: 'POST', signal
    },
      );
    }
  


export const getSummarizeAssessmentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof summarizeAssessment>>, TError,{uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof summarizeAssessment>>, TError,{uid: string}, TContext> => {
    
const mutationKey = ['summarizeAssessment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof summarizeAssessment>>, {uid: string}> = (props) => {
          const {uid} = props ?? {};

          return  summarizeAssessment(uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SummarizeAssessmentMutationResult = NonNullable<Awaited<ReturnType<typeof summarizeAssessment>>>
    
    export type SummarizeAssessmentMutationError = unknown

    /**
 * @summary アセスメントの要約を作成
 */
export const useSummarizeAssessment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof summarizeAssessment>>, TError,{uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof summarizeAssessment>>,
        TError,
        {uid: string},
        TContext
      > => {

      const mutationOptions = getSummarizeAssessmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary テナント内のアセスメント対象者一覧を取得
 */
export const getSubjects = (
    tenantUid?: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SubjectListResponseDto>(
      {url: `/tenants/${tenantUid}/subjects`, method: 'GET', signal
    },
      );
    }
  

export const getGetSubjectsQueryKey = (tenantUid?: string,) => {
    return [`/tenants/${tenantUid}/subjects`] as const;
    }

    
export const getGetSubjectsQueryOptions = <TData = Awaited<ReturnType<typeof getSubjects>>, TError = unknown>(tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjects>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectsQueryKey(tenantUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubjects>>> = ({ signal }) => getSubjects(tenantUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(tenantUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubjects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSubjectsQueryResult = NonNullable<Awaited<ReturnType<typeof getSubjects>>>
export type GetSubjectsQueryError = unknown


export function useGetSubjects<TData = Awaited<ReturnType<typeof getSubjects>>, TError = unknown>(
 tenantUid: undefined |  string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubjects>>,
          TError,
          Awaited<ReturnType<typeof getSubjects>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubjects<TData = Awaited<ReturnType<typeof getSubjects>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubjects>>,
          TError,
          Awaited<ReturnType<typeof getSubjects>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubjects<TData = Awaited<ReturnType<typeof getSubjects>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjects>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary テナント内のアセスメント対象者一覧を取得
 */

export function useGetSubjects<TData = Awaited<ReturnType<typeof getSubjects>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjects>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSubjectsQueryOptions(tenantUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary テナントにアセスメント対象者を作成
 */
export const createSubject = (
    tenantUid: string,
    subjectCreateInputDto: SubjectCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SubjectDto>(
      {url: `/tenants/${tenantUid}/subjects`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: subjectCreateInputDto, signal
    },
      );
    }
  


export const getCreateSubjectMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSubject>>, TError,{tenantUid: string;data: SubjectCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSubject>>, TError,{tenantUid: string;data: SubjectCreateInputDto}, TContext> => {
    
const mutationKey = ['createSubject'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSubject>>, {tenantUid: string;data: SubjectCreateInputDto}> = (props) => {
          const {tenantUid,data} = props ?? {};

          return  createSubject(tenantUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof createSubject>>>
    export type CreateSubjectMutationBody = SubjectCreateInputDto
    export type CreateSubjectMutationError = unknown

    /**
 * @summary テナントにアセスメント対象者を作成
 */
export const useCreateSubject = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSubject>>, TError,{tenantUid: string;data: SubjectCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createSubject>>,
        TError,
        {tenantUid: string;data: SubjectCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateSubjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アセスメント対象者の詳細を取得
 */
export const getSubject = (
    tenantUid: string,
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SubjectDto>(
      {url: `/tenants/${tenantUid}/subjects/${uid}`, method: 'GET', signal
    },
      );
    }
  

export const getGetSubjectQueryKey = (tenantUid: string,
    uid: string,) => {
    return [`/tenants/${tenantUid}/subjects/${uid}`] as const;
    }

    
export const getGetSubjectQueryOptions = <TData = Awaited<ReturnType<typeof getSubject>>, TError = unknown>(tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectQueryKey(tenantUid,uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubject>>> = ({ signal }) => getSubject(tenantUid,uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(tenantUid && uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSubjectQueryResult = NonNullable<Awaited<ReturnType<typeof getSubject>>>
export type GetSubjectQueryError = unknown


export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = unknown>(
 tenantUid: string,
    uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubject>>,
          TError,
          Awaited<ReturnType<typeof getSubject>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = unknown>(
 tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubject>>,
          TError,
          Awaited<ReturnType<typeof getSubject>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = unknown>(
 tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary アセスメント対象者の詳細を取得
 */

export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = unknown>(
 tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSubjectQueryOptions(tenantUid,uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary アセスメント対象者を更新
 */
export const updateSubject = (
    tenantUid: string,
    uid: string,
    subjectUpdateInputDto: SubjectUpdateInputDto,
 ) => {
      
      
      return customInstance<SubjectDto>(
      {url: `/tenants/${tenantUid}/subjects/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: subjectUpdateInputDto
    },
      );
    }
  


export const getUpdateSubjectMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSubject>>, TError,{tenantUid: string;uid: string;data: SubjectUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateSubject>>, TError,{tenantUid: string;uid: string;data: SubjectUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateSubject'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSubject>>, {tenantUid: string;uid: string;data: SubjectUpdateInputDto}> = (props) => {
          const {tenantUid,uid,data} = props ?? {};

          return  updateSubject(tenantUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof updateSubject>>>
    export type UpdateSubjectMutationBody = SubjectUpdateInputDto
    export type UpdateSubjectMutationError = unknown

    /**
 * @summary アセスメント対象者を更新
 */
export const useUpdateSubject = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSubject>>, TError,{tenantUid: string;uid: string;data: SubjectUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateSubject>>,
        TError,
        {tenantUid: string;uid: string;data: SubjectUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateSubjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アセスメント対象者を削除
 */
export const deleteSubject = (
    tenantUid: string,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/tenants/${tenantUid}/subjects/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteSubjectMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSubject>>, TError,{tenantUid: string;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteSubject>>, TError,{tenantUid: string;uid: string}, TContext> => {
    
const mutationKey = ['deleteSubject'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSubject>>, {tenantUid: string;uid: string}> = (props) => {
          const {tenantUid,uid} = props ?? {};

          return  deleteSubject(tenantUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSubject>>>
    
    export type DeleteSubjectMutationError = unknown

    /**
 * @summary アセスメント対象者を削除
 */
export const useDeleteSubject = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSubject>>, TError,{tenantUid: string;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteSubject>>,
        TError,
        {tenantUid: string;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteSubjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
