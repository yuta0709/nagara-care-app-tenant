/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Nagara Care API
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import { customInstance } from './custom-instance';
export interface SignInDto {
  loginId: string;
  password: string;
}

export interface TokenDto {
  /** JWTトークン */
  token: string;
}

export interface UserDto {
  /** ユーザーUID */
  uid: string;
  /** ログインID */
  loginId: string;
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** ユーザー権限 */
  role: string;
  /** テナントUID */
  tenantUid: string;
}

/**
 * ロール
 */
export type UserListItemDtoRole = typeof UserListItemDtoRole[keyof typeof UserListItemDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserListItemDtoRole = {
  GLOBAL_ADMIN: 'GLOBAL_ADMIN',
  TENANT_ADMIN: 'TENANT_ADMIN',
  CAREGIVER: 'CAREGIVER',
} as const;

export interface UserListItemDto {
  /** ユーザーUID */
  uid: string;
  /** ログインID */
  loginId: string;
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** ロール */
  role: UserListItemDtoRole;
  /** 作成日時 */
  createdAt: string;
}

export interface UserListResponseDto {
  /** ユーザー一覧 */
  items: UserListItemDto[];
  /** 総件数 */
  total: number;
}

export interface TenantUserCreateInputDto {
  /** ログインID */
  loginId: string;
  /** パスワード */
  password: string;
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** ユーザー権限 */
  role: string;
}

/**
 * ユーザーロール
 */
export type UserUpdateInputDtoRole = typeof UserUpdateInputDtoRole[keyof typeof UserUpdateInputDtoRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserUpdateInputDtoRole = {
  GLOBAL_ADMIN: 'GLOBAL_ADMIN',
  TENANT_ADMIN: 'TENANT_ADMIN',
  CAREGIVER: 'CAREGIVER',
} as const;

export interface UserUpdateInputDto {
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** ユーザーロール */
  role: UserUpdateInputDtoRole;
}

export interface TenantListItemDto {
  /** テナントUID */
  uid: string;
  /** テナント名 */
  name: string;
  /** 作成日時 */
  createdAt: string;
}

export interface TenantListResponseDto {
  /** テナント一覧 */
  items: TenantListItemDto[];
  /** 総件数 */
  total: number;
}

export interface TenantDto {
  /** テナントUID */
  uid: string;
  /** テナント名 */
  name: string;
  /** 作成日時 */
  createdAt: string;
}

export interface TenantCreateInputDto {
  /** テナント名 */
  name: string;
}

export interface TenantUpdateInputDto {
  /** テナント名 */
  name: string;
}

/**
 * 性別
 */
export type ResidentDtoGender = typeof ResidentDtoGender[keyof typeof ResidentDtoGender];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResidentDtoGender = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
} as const;

export interface ResidentDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** 生年月日 */
  dateOfBirth: string;
  /** 性別 */
  gender: ResidentDtoGender;
  /** 入所日 */
  admissionDate: string;
  /** 作成日時 */
  createdAt: string;
}

export interface ResidentListResponseDto {
  items: ResidentDto[];
  /** 総件数 */
  total: number;
}

/**
 * 性別
 */
export type ResidentCreateInputDtoGender = typeof ResidentCreateInputDtoGender[keyof typeof ResidentCreateInputDtoGender];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResidentCreateInputDtoGender = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
} as const;

export interface ResidentCreateInputDto {
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** 生年月日 */
  dateOfBirth: string;
  /** 性別 */
  gender: ResidentCreateInputDtoGender;
  /** 入所日 */
  admissionDate: string;
}

/**
 * 性別
 */
export type ResidentUpdateInputDtoGender = typeof ResidentUpdateInputDtoGender[keyof typeof ResidentUpdateInputDtoGender];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResidentUpdateInputDtoGender = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
} as const;

export interface ResidentUpdateInputDto {
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** 生年月日 */
  dateOfBirth: string;
  /** 性別 */
  gender: ResidentUpdateInputDtoGender;
  /** 入所日 */
  admissionDate: string;
}

/**
 * 食事の時間帯
 */
export type FoodRecordDtoMealTime = typeof FoodRecordDtoMealTime[keyof typeof FoodRecordDtoMealTime];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordDtoMealTime = {
  BREAKFAST: 'BREAKFAST',
  LUNCH: 'LUNCH',
  DINNER: 'DINNER',
} as const;

/**
 * 飲み物の種類
 */
export type FoodRecordDtoBeverageType = typeof FoodRecordDtoBeverageType[keyof typeof FoodRecordDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface FoodRecordDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 介護者UID */
  caregiverUid: string;
  /** 利用者UID */
  residentUid: string;
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes: string;
  /** 食事の時間帯 */
  mealTime: FoodRecordDtoMealTime;
  /** 主食の摂取率（%） */
  mainCoursePercentage: number;
  /** 副食の摂取率（%） */
  sideDishPercentage: number;
  /** 汁物の摂取率（%） */
  soupPercentage: number;
  /** 飲み物の種類 */
  beverageType: FoodRecordDtoBeverageType;
  /** 飲み物の摂取量（ml） */
  beverageVolume: number;
}

export interface FoodRecordListResponseDto {
  items: FoodRecordDto[];
  /** 総件数 */
  total: number;
}

export interface DailyFoodRecordsDto {
  /** 日付 */
  date: string;
  /** 朝食の記録 */
  breakfast?: FoodRecordDto;
  /** 昼食の記録 */
  lunch?: FoodRecordDto;
  /** 夕食の記録 */
  dinner?: FoodRecordDto;
}

export interface DailyFoodRecordsListResponseDto {
  /** 日別食事記録一覧 */
  items: DailyFoodRecordsDto[];
  /** 総日数 */
  total: number;
}

/**
 * 食事の時間帯
 */
export type FoodRecordCreateInputDtoMealTime = typeof FoodRecordCreateInputDtoMealTime[keyof typeof FoodRecordCreateInputDtoMealTime];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordCreateInputDtoMealTime = {
  BREAKFAST: 'BREAKFAST',
  LUNCH: 'LUNCH',
  DINNER: 'DINNER',
} as const;

/**
 * 飲み物の種類
 */
export type FoodRecordCreateInputDtoBeverageType = typeof FoodRecordCreateInputDtoBeverageType[keyof typeof FoodRecordCreateInputDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordCreateInputDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface FoodRecordCreateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 食事の時間帯 */
  mealTime: FoodRecordCreateInputDtoMealTime;
  /**
   * 主食の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  mainCoursePercentage: number;
  /**
   * 副食の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  sideDishPercentage: number;
  /**
   * 汁物の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  soupPercentage: number;
  /** 飲み物の種類 */
  beverageType: FoodRecordCreateInputDtoBeverageType;
  /**
   * 飲み物の摂取量（ml）
   * @minimum 0
   */
  beverageVolume: number;
}

/**
 * 食事の時間帯
 */
export type FoodRecordUpdateInputDtoMealTime = typeof FoodRecordUpdateInputDtoMealTime[keyof typeof FoodRecordUpdateInputDtoMealTime];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordUpdateInputDtoMealTime = {
  BREAKFAST: 'BREAKFAST',
  LUNCH: 'LUNCH',
  DINNER: 'DINNER',
} as const;

/**
 * 飲み物の種類
 */
export type FoodRecordUpdateInputDtoBeverageType = typeof FoodRecordUpdateInputDtoBeverageType[keyof typeof FoodRecordUpdateInputDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FoodRecordUpdateInputDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface FoodRecordUpdateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 食事の時間帯 */
  mealTime: FoodRecordUpdateInputDtoMealTime;
  /**
   * 主食の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  mainCoursePercentage: number;
  /**
   * 副食の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  sideDishPercentage: number;
  /**
   * 汁物の摂取率（%）
   * @minimum 0
   * @maximum 100
   */
  soupPercentage: number;
  /** 飲み物の種類 */
  beverageType: FoodRecordUpdateInputDtoBeverageType;
  /**
   * 飲み物の摂取量（ml）
   * @minimum 0
   */
  beverageVolume: number;
}

export interface TranscriptionDto {
  /** 文字起こしテキスト */
  transcription: string;
}

export interface TranscriptionInputDto {
  transcription: string;
}

export interface FoodRecordExtractedDto {
  /** 主食の摂取率（0-100%） */
  mainCoursePercentage: number;
  /** 副食の摂取率（0-100%） */
  sideDishPercentage: number;
  /** 汁物の摂取率（0-100%） */
  soupPercentage: number;
  /** 飲み物の種類（水、お茶、その他） */
  beverageType: string;
  /** 飲み物の摂取量（ml） */
  beverageVolume: number;
  /** 特記事項 */
  notes: string;
}

export interface BathRecordDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 介護者UID */
  caregiverUid: string;
  /** 利用者UID */
  residentUid: string;
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes: string;
  /** 入浴方法 */
  bathMethod: string;
}

export interface BathRecordListResponseDto {
  items: BathRecordDto[];
  /** 総件数 */
  total: number;
}

export interface BathRecordCreateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 入浴方法 */
  bathMethod: string;
}

export interface BathRecordUpdateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 入浴方法 */
  bathMethod: string;
}

export interface BathRecordExtractedDto {
  /** 入浴方法 */
  bathMethod: string;
  /** 特記事項 */
  notes: string;
}

export interface EliminationRecordDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 介護者UID */
  caregiverUid: string;
  /** 利用者UID */
  residentUid: string;
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes: string;
  /** 排泄方法 */
  eliminationMethod: string;
  /** 便の有無 */
  hasFeces: boolean;
  /** 便失禁の有無 */
  fecalIncontinence: boolean;
  /** 便の性状 */
  fecesAppearance: string;
  /** 便の量（g） */
  fecesVolume: number;
  /** 尿の有無 */
  hasUrine: boolean;
  /** 尿失禁の有無 */
  urinaryIncontinence: boolean;
  /** 尿の性状 */
  urineAppearance: string;
  /** 尿量（ml） */
  urineVolume: number;
}

export interface EliminationRecordListResponseDto {
  items: EliminationRecordDto[];
  /** 総件数 */
  total: number;
}

export interface EliminationRecordCreateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 排泄方法 */
  eliminationMethod: string;
  /** 便の有無 */
  hasFeces: boolean;
  /** 便失禁の有無 */
  fecalIncontinence?: boolean;
  /** 便の性状 */
  fecesAppearance?: string;
  /**
   * 便の量（g）
   * @minimum 0
   */
  fecesVolume?: number;
  /** 尿の有無 */
  hasUrine: boolean;
  /** 尿失禁の有無 */
  urinaryIncontinence?: boolean;
  /** 尿の性状 */
  urineAppearance?: string;
  /**
   * 尿量（ml）
   * @minimum 0
   */
  urineVolume?: number;
}

export interface EliminationRecordUpdateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 排泄方法 */
  eliminationMethod: string;
  /** 便の有無 */
  hasFeces: boolean;
  /** 便失禁の有無 */
  fecalIncontinence?: boolean;
  /** 便の性状 */
  fecesAppearance?: string;
  /**
   * 便の量（g）
   * @minimum 0
   */
  fecesVolume?: number;
  /** 尿の有無 */
  hasUrine: boolean;
  /** 尿失禁の有無 */
  urinaryIncontinence?: boolean;
  /** 尿の性状 */
  urineAppearance?: string;
  /**
   * 尿量（ml）
   * @minimum 0
   */
  urineVolume?: number;
}

/**
 * 日常の状態
 */
export type DailyRecordDtoDailyStatus = typeof DailyRecordDtoDailyStatus[keyof typeof DailyRecordDtoDailyStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DailyRecordDtoDailyStatus = {
  NORMAL: 'NORMAL',
  WARNING: 'WARNING',
  ALERT: 'ALERT',
} as const;

export interface DailyRecordDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 介護者UID */
  caregiverUid: string;
  /** 利用者UID */
  residentUid: string;
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes: string;
  /** 日常の状態 */
  dailyStatus: DailyRecordDtoDailyStatus;
}

export interface DailyRecordListResponseDto {
  items: DailyRecordDto[];
  /** 総件数 */
  total: number;
}

/**
 * 日常の状態
 */
export type DailyRecordCreateInputDtoDailyStatus = typeof DailyRecordCreateInputDtoDailyStatus[keyof typeof DailyRecordCreateInputDtoDailyStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DailyRecordCreateInputDtoDailyStatus = {
  NORMAL: 'NORMAL',
  WARNING: 'WARNING',
  ALERT: 'ALERT',
} as const;

export interface DailyRecordCreateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 日常の状態 */
  dailyStatus?: DailyRecordCreateInputDtoDailyStatus;
}

/**
 * 日常の状態
 */
export type DailyRecordUpdateInputDtoDailyStatus = typeof DailyRecordUpdateInputDtoDailyStatus[keyof typeof DailyRecordUpdateInputDtoDailyStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DailyRecordUpdateInputDtoDailyStatus = {
  NORMAL: 'NORMAL',
  WARNING: 'WARNING',
  ALERT: 'ALERT',
} as const;

export interface DailyRecordUpdateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 日常の状態 */
  dailyStatus?: DailyRecordUpdateInputDtoDailyStatus;
}

/**
 * 飲み物の種類
 */
export type BeverageRecordDtoBeverageType = typeof BeverageRecordDtoBeverageType[keyof typeof BeverageRecordDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BeverageRecordDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface BeverageRecordDto {
  /** UID */
  uid: string;
  /** テナントUID */
  tenantUid: string;
  /** 介護者UID */
  caregiverUid: string;
  /** 利用者UID */
  residentUid: string;
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes: string;
  /** 飲み物の種類 */
  beverageType: BeverageRecordDtoBeverageType;
  /** 飲み物の量（ml） */
  volume: number;
}

export interface BeverageRecordListResponseDto {
  items: BeverageRecordDto[];
  /** 総件数 */
  total: number;
}

/**
 * 飲み物の種類
 */
export type BeverageRecordCreateInputDtoBeverageType = typeof BeverageRecordCreateInputDtoBeverageType[keyof typeof BeverageRecordCreateInputDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BeverageRecordCreateInputDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface BeverageRecordCreateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 飲み物の種類 */
  beverageType: BeverageRecordCreateInputDtoBeverageType;
  /**
   * 飲み物の量（ml）
   * @minimum 0
   */
  volume: number;
}

/**
 * 飲み物の種類
 */
export type BeverageRecordUpdateInputDtoBeverageType = typeof BeverageRecordUpdateInputDtoBeverageType[keyof typeof BeverageRecordUpdateInputDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BeverageRecordUpdateInputDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface BeverageRecordUpdateInputDto {
  /** 記録時刻 */
  recordedAt: string;
  /** メモ */
  notes?: string;
  /** 飲み物の種類 */
  beverageType: BeverageRecordUpdateInputDtoBeverageType;
  /**
   * 飲み物の量（ml）
   * @minimum 0
   */
  volume: number;
}

/**
 * 飲み物の種類
 */
export type BeverageRecordExtractedDtoBeverageType = typeof BeverageRecordExtractedDtoBeverageType[keyof typeof BeverageRecordExtractedDtoBeverageType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BeverageRecordExtractedDtoBeverageType = {
  WATER: 'WATER',
  TEA: 'TEA',
  OTHER: 'OTHER',
} as const;

export interface BeverageRecordExtractedDto {
  /** 飲み物の種類 */
  beverageType: BeverageRecordExtractedDtoBeverageType;
  /** 飲み物の量（ml） */
  volume: number;
  /** 特記事項 */
  notes: string;
}

/**
 * 性別
 */
export type SubjectDtoGender = typeof SubjectDtoGender[keyof typeof SubjectDtoGender];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SubjectDtoGender = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
} as const;

export interface SubjectDto {
  /** UID */
  uid: string;
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** 生年月日 */
  dateOfBirth: string;
  /** 性別 */
  gender: SubjectDtoGender;
  /** テナントUID */
  tenantUid: string;
  /** 作成日時 */
  createdAt: string;
}

/**
 * 要介護状態区分
 */
export type AssessmentDtoCareLevel = typeof AssessmentDtoCareLevel[keyof typeof AssessmentDtoCareLevel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssessmentDtoCareLevel = {
  NEEDS_CARE_1: 'NEEDS_CARE_1',
  NEEDS_CARE_2: 'NEEDS_CARE_2',
  NEEDS_CARE_3: 'NEEDS_CARE_3',
  NEEDS_CARE_4: 'NEEDS_CARE_4',
  NEEDS_CARE_5: 'NEEDS_CARE_5',
} as const;

/**
 * 障害高齢者の日常生活自立度判定基準
 */
export type AssessmentDtoPhysicalIndependence = typeof AssessmentDtoPhysicalIndependence[keyof typeof AssessmentDtoPhysicalIndependence];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssessmentDtoPhysicalIndependence = {
  INDEPENDENT: 'INDEPENDENT',
  J1: 'J1',
  J2: 'J2',
  A1: 'A1',
  A2: 'A2',
  B1: 'B1',
  B2: 'B2',
  C1: 'C1',
  C2: 'C2',
} as const;

/**
 * 認知症高齢者の日常生活自立度判定基準
 */
export type AssessmentDtoCognitiveIndependence = typeof AssessmentDtoCognitiveIndependence[keyof typeof AssessmentDtoCognitiveIndependence];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssessmentDtoCognitiveIndependence = {
  INDEPENDENT: 'INDEPENDENT',
  I: 'I',
  IIa: 'IIa',
  IIb: 'IIb',
  IIIa: 'IIIa',
  IIIb: 'IIIb',
  IV: 'IV',
  M: 'M',
} as const;

export interface AssessmentDto {
  /** UID */
  uid: string;
  /** アセスメント対象者UID */
  subjectUid: string;
  /** アセスメント対象者 */
  subject: SubjectDto;
  /** テナントUID */
  tenantUid: string;
  /** 記入者UID */
  userUid: string;
  /** 家族構成 */
  familyInfo: string;
  /** 要介護状態区分 */
  careLevel: AssessmentDtoCareLevel;
  /** 障害高齢者の日常生活自立度判定基準 */
  physicalIndependence: AssessmentDtoPhysicalIndependence;
  /** 認知症高齢者の日常生活自立度判定基準 */
  cognitiveIndependence: AssessmentDtoCognitiveIndependence;
  /** 既往症 */
  medicalHistory: string;
  /** 服用薬剤 */
  medications: string;
  /** 使用しているフォーマルサービス */
  formalServices: string;
  /** 使用しているインフォーマルサービス */
  informalSupport: string;
  /** 相談に至った経緯 */
  consultationBackground: string;
  /** 生活史 */
  lifeHistory: string;
  /** 主訴 */
  complaints: string;
  /** 健康状態 */
  healthNotes: string;
  /** 精神状態 */
  mentalStatus: string;
  /** 身体状態 */
  physicalStatus: string;
  /** ADL */
  adlStatus: string;
  /** コミュニケーション */
  communication: string;
  /** 日常生活 */
  dailyLife: string;
  /** IADL */
  instrumentalADL: string;
  /** 参加・参加制約 */
  participation: string;
  /** 環境 */
  environment: string;
  /** 生活状況 */
  livingSituation: string;
  /** 制度的環境 */
  legalSupport: string;
  /** 個人因子 */
  personalTraits: string;
  /** 作成日時 */
  createdAt: string;
}

export interface AssessmentListResponseDto {
  /** アセスメント一覧 */
  items: AssessmentDto[];
  /** 総件数 */
  total: number;
}

export interface AssessmentCreateInputDto {
  /** アセスメント対象者UID */
  subjectUid: string;
}

/**
 * 要介護状態区分
 */
export type AssessmentUpdateInputDtoCareLevel = typeof AssessmentUpdateInputDtoCareLevel[keyof typeof AssessmentUpdateInputDtoCareLevel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssessmentUpdateInputDtoCareLevel = {
  NEEDS_CARE_1: 'NEEDS_CARE_1',
  NEEDS_CARE_2: 'NEEDS_CARE_2',
  NEEDS_CARE_3: 'NEEDS_CARE_3',
  NEEDS_CARE_4: 'NEEDS_CARE_4',
  NEEDS_CARE_5: 'NEEDS_CARE_5',
} as const;

/**
 * 障害高齢者の日常生活自立度判定基準
 */
export type AssessmentUpdateInputDtoPhysicalIndependence = typeof AssessmentUpdateInputDtoPhysicalIndependence[keyof typeof AssessmentUpdateInputDtoPhysicalIndependence];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssessmentUpdateInputDtoPhysicalIndependence = {
  INDEPENDENT: 'INDEPENDENT',
  J1: 'J1',
  J2: 'J2',
  A1: 'A1',
  A2: 'A2',
  B1: 'B1',
  B2: 'B2',
  C1: 'C1',
  C2: 'C2',
} as const;

/**
 * 認知症高齢者の日常生活自立度判定基準
 */
export type AssessmentUpdateInputDtoCognitiveIndependence = typeof AssessmentUpdateInputDtoCognitiveIndependence[keyof typeof AssessmentUpdateInputDtoCognitiveIndependence];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AssessmentUpdateInputDtoCognitiveIndependence = {
  INDEPENDENT: 'INDEPENDENT',
  I: 'I',
  IIa: 'IIa',
  IIb: 'IIb',
  IIIa: 'IIIa',
  IIIb: 'IIIb',
  IV: 'IV',
  M: 'M',
} as const;

export interface AssessmentUpdateInputDto {
  /** 家族構成 */
  familyInfo?: string;
  /** 要介護状態区分 */
  careLevel?: AssessmentUpdateInputDtoCareLevel;
  /** 障害高齢者の日常生活自立度判定基準 */
  physicalIndependence?: AssessmentUpdateInputDtoPhysicalIndependence;
  /** 認知症高齢者の日常生活自立度判定基準 */
  cognitiveIndependence?: AssessmentUpdateInputDtoCognitiveIndependence;
  /** 既往症 */
  medicalHistory?: string;
  /** 服用薬剤 */
  medications?: string;
  /** 使用しているフォーマルサービス */
  formalServices?: string;
  /** 使用しているインフォーマルサービス */
  informalSupport?: string;
  /** 相談に至った経緯 */
  consultationBackground?: string;
  /** 生活史 */
  lifeHistory?: string;
  /** 主訴 */
  complaints?: string;
  /** 健康状態 */
  healthNotes?: string;
  /** 精神状態 */
  mentalStatus?: string;
  /** 身体状態 */
  physicalStatus?: string;
  /** ADL */
  adlStatus?: string;
  /** コミュニケーション */
  communication?: string;
  /** 日常生活 */
  dailyLife?: string;
  /** IADL */
  instrumentalADL?: string;
  /** 参加・参加制約 */
  participation?: string;
  /** 環境 */
  environment?: string;
  /** 生活状況 */
  livingSituation?: string;
  /** 制度的環境 */
  legalSupport?: string;
  /** 個人因子 */
  personalTraits?: string;
}

export interface SubjectListResponseDto {
  /** アセスメント対象者一覧 */
  items: SubjectDto[];
  /** 総件数 */
  total: number;
}

/**
 * 性別
 */
export type SubjectCreateInputDtoGender = typeof SubjectCreateInputDtoGender[keyof typeof SubjectCreateInputDtoGender];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SubjectCreateInputDtoGender = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
} as const;

export interface SubjectCreateInputDto {
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** 生年月日 */
  dateOfBirth: string;
  /** 性別 */
  gender: SubjectCreateInputDtoGender;
}

/**
 * 性別
 */
export type SubjectUpdateInputDtoGender = typeof SubjectUpdateInputDtoGender[keyof typeof SubjectUpdateInputDtoGender];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SubjectUpdateInputDtoGender = {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
} as const;

export interface SubjectUpdateInputDto {
  /** 姓 */
  familyName: string;
  /** 名 */
  givenName: string;
  /** 姓（フリガナ） */
  familyNameFurigana: string;
  /** 名（フリガナ） */
  givenNameFurigana: string;
  /** 生年月日 */
  dateOfBirth: string;
  /** 性別 */
  gender: SubjectUpdateInputDtoGender;
}

export interface ThreadCreateOutputDto {
  uid: string;
  title: string;
  createdByUid: string;
  createdAt: string;
  updatedAt: string;
}

export interface ThreadListItemOutputDto {
  uid: string;
  title: string;
  createdByUid: string;
  createdAt: string;
  updatedAt: string;
}

export interface ThreadListOutputDto {
  items: ThreadListItemOutputDto[];
  total: number;
}

export interface MessageOutputDto {
  uid: string;
  threadUid: string;
  content: string;
  role: string;
  createdAt: string;
  updatedAt: string;
}

export interface ThreadOutputDto {
  uid: string;
  title: string;
  createdByUid: string;
  createdAt: string;
  updatedAt: string;
  messages: MessageOutputDto[];
}

export interface ThreadUpdateInputDto {
  title: string;
}

export interface MessageCreateInputDto { [key: string]: unknown }

export interface CreateQaSessionDto {
  /** タイトル */
  title: string;
}

export interface QuestionAnswerOutputDto {
  /** 質問回答UID */
  uid: string;
  /** 質問 */
  question: string;
  /** 回答 */
  answer: string;
  /** 作成日時 */
  createdAt: string;
  /** 更新日時 */
  updatedAt: string;
}

export interface QaSessionOutputDto {
  /** QAセッションUID */
  uid: string;
  /** ユーザーUID */
  userUid: string;
  /** 質問回答 */
  questionAnswers: QuestionAnswerOutputDto[];
  /** 作成日時 */
  createdAt: string;
  /** 更新日時 */
  updatedAt: string;
  /** 文字起こし */
  transcription: string;
}

export interface QaSessionListOutputDto {
  items: QaSessionOutputDto[];
  /** 総数 */
  total: number;
}

export interface CreateQuestionAnswerDto {
  /** QAセッションID */
  qaSessionUid: string;
  /** 質問内容 */
  question: string;
  /** 回答内容 */
  answer: string;
}

export interface UpdateQuestionAnswerDto {
  /** 質問回答ID */
  uid: string;
  /** 質問内容 */
  question: string;
  /** 回答内容 */
  answer: string;
}

export interface QuestionAnswerItem {
  /** 質問内容 */
  question: string;
  /** 回答内容 */
  answer: string;
}

export interface UpsertQuestionAnswersDto {
  /** 質問と回答のリスト */
  questionAnswers: QuestionAnswerItem[];
}

export interface ExtractedQaPair {
  question: string;
  answer: string;
}

export interface ExtractQaPairsOutputDto {
  data: ExtractedQaPair[];
}

export type GetDailyFoodRecordsParams = {
/**
 * 開始日（YYYY-MM-DD形式）。指定しない場合は過去30日間
 */
startDate?: string;
/**
 * 終了日（YYYY-MM-DD形式）。指定しない場合は現在日
 */
endDate?: string;
};





export const appControllerGetHello = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/`, method: 'GET', signal
    },
      );
    }
  

export const getAppControllerGetHelloQueryKey = () => {
    return [`/`] as const;
    }

    
export const getAppControllerGetHelloQueryOptions = <TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAppControllerGetHelloQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerGetHello>>> = ({ signal }) => appControllerGetHello(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppControllerGetHelloQueryResult = NonNullable<Awaited<ReturnType<typeof appControllerGetHello>>>
export type AppControllerGetHelloQueryError = unknown


export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAppControllerGetHello<TData = Awaited<ReturnType<typeof appControllerGetHello>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAppControllerGetHelloQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary ログイン
 */
export const login = (
    signInDto: SignInDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TokenDto>(
      {url: `/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: signInDto, signal
    },
      );
    }
  


export const getLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: SignInDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: SignInDto}, TContext> => {
    
const mutationKey = ['login'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: SignInDto}> = (props) => {
          const {data} = props ?? {};

          return  login(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = SignInDto
    export type LoginMutationError = unknown

    /**
 * @summary ログイン
 */
export const useLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: SignInDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: SignInDto},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ログイン中のユーザー情報を取得
 */
export const getMe = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserDto>(
      {url: `/auth/me`, method: 'GET', signal
    },
      );
    }
  

export const getGetMeQueryKey = () => {
    return [`/auth/me`] as const;
    }

    
export const getGetMeQueryOptions = <TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMe>>> = ({ signal }) => getMe(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMeQueryResult = NonNullable<Awaited<ReturnType<typeof getMe>>>
export type GetMeQueryError = unknown


export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ログイン中のユーザー情報を取得
 */

export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMeQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary テナント内のユーザー一覧を取得
 */
export const getUsers = (
    tenantUid?: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserListResponseDto>(
      {url: `/tenants/${tenantUid}/users`, method: 'GET', signal
    },
      );
    }
  

export const getGetUsersQueryKey = (tenantUid?: string,) => {
    return [`/tenants/${tenantUid}/users`] as const;
    }

    
export const getGetUsersQueryOptions = <TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersQueryKey(tenantUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(tenantUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(tenantUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersQueryError = unknown


export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
 tenantUid: undefined |  string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsers>>,
          TError,
          Awaited<ReturnType<typeof getUsers>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsers>>,
          TError,
          Awaited<ReturnType<typeof getUsers>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary テナント内のユーザー一覧を取得
 */

export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersQueryOptions(tenantUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary テナントにユーザーを作成
 */
export const createUser = (
    tenantUid: string,
    tenantUserCreateInputDto: TenantUserCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserDto>(
      {url: `/tenants/${tenantUid}/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tenantUserCreateInputDto, signal
    },
      );
    }
  


export const getCreateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{tenantUid: string;data: TenantUserCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{tenantUid: string;data: TenantUserCreateInputDto}, TContext> => {
    
const mutationKey = ['createUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {tenantUid: string;data: TenantUserCreateInputDto}> = (props) => {
          const {tenantUid,data} = props ?? {};

          return  createUser(tenantUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = TenantUserCreateInputDto
    export type CreateUserMutationError = unknown

    /**
 * @summary テナントにユーザーを作成
 */
export const useCreateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{tenantUid: string;data: TenantUserCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {tenantUid: string;data: TenantUserCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ユーザーを更新
 */
export const updateUser = (
    uid: string,
    userUpdateInputDto: UserUpdateInputDto,
 ) => {
      
      
      return customInstance<UserDto>(
      {url: `/users/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: userUpdateInputDto
    },
      );
    }
  


export const getUpdateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{uid: string;data: UserUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{uid: string;data: UserUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {uid: string;data: UserUpdateInputDto}> = (props) => {
          const {uid,data} = props ?? {};

          return  updateUser(uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UserUpdateInputDto
    export type UpdateUserMutationError = unknown

    /**
 * @summary ユーザーを更新
 */
export const useUpdateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{uid: string;data: UserUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {uid: string;data: UserUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ユーザーを削除
 */
export const deleteUser = (
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/users/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{uid: string}, TContext> => {
    
const mutationKey = ['deleteUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {uid: string}> = (props) => {
          const {uid} = props ?? {};

          return  deleteUser(uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = unknown

    /**
 * @summary ユーザーを削除
 */
export const useDeleteUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary テナント一覧を取得
 */
export const getTenants = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<TenantListResponseDto>(
      {url: `/tenants`, method: 'GET', signal
    },
      );
    }
  

export const getGetTenantsQueryKey = () => {
    return [`/tenants`] as const;
    }

    
export const getGetTenantsQueryOptions = <TData = Awaited<ReturnType<typeof getTenants>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenants>>> = ({ signal }) => getTenants(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTenantsQueryResult = NonNullable<Awaited<ReturnType<typeof getTenants>>>
export type GetTenantsQueryError = unknown


export function useGetTenants<TData = Awaited<ReturnType<typeof getTenants>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenants>>,
          TError,
          Awaited<ReturnType<typeof getTenants>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenants<TData = Awaited<ReturnType<typeof getTenants>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenants>>,
          TError,
          Awaited<ReturnType<typeof getTenants>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenants<TData = Awaited<ReturnType<typeof getTenants>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary テナント一覧を取得
 */

export function useGetTenants<TData = Awaited<ReturnType<typeof getTenants>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenants>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTenantsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary テナントを作成する
 */
export const createTenant = (
    tenantCreateInputDto: TenantCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TenantDto>(
      {url: `/tenants`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tenantCreateInputDto, signal
    },
      );
    }
  


export const getCreateTenantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTenant>>, TError,{data: TenantCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createTenant>>, TError,{data: TenantCreateInputDto}, TContext> => {
    
const mutationKey = ['createTenant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTenant>>, {data: TenantCreateInputDto}> = (props) => {
          const {data} = props ?? {};

          return  createTenant(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTenantMutationResult = NonNullable<Awaited<ReturnType<typeof createTenant>>>
    export type CreateTenantMutationBody = TenantCreateInputDto
    export type CreateTenantMutationError = unknown

    /**
 * @summary テナントを作成する
 */
export const useCreateTenant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTenant>>, TError,{data: TenantCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createTenant>>,
        TError,
        {data: TenantCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateTenantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary テナントの詳細を取得
 */
export const getTenant = (
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TenantDto>(
      {url: `/tenants/${uid}`, method: 'GET', signal
    },
      );
    }
  

export const getGetTenantQueryKey = (uid: string,) => {
    return [`/tenants/${uid}`] as const;
    }

    
export const getGetTenantQueryOptions = <TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantQueryKey(uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenant>>> = ({ signal }) => getTenant(uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTenantQueryResult = NonNullable<Awaited<ReturnType<typeof getTenant>>>
export type GetTenantQueryError = unknown


export function useGetTenant<TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(
 uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenant>>,
          TError,
          Awaited<ReturnType<typeof getTenant>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenant<TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenant>>,
          TError,
          Awaited<ReturnType<typeof getTenant>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenant<TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary テナントの詳細を取得
 */

export function useGetTenant<TData = Awaited<ReturnType<typeof getTenant>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenant>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTenantQueryOptions(uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary テナントを更新
 */
export const updateTenant = (
    uid: string,
    tenantUpdateInputDto: TenantUpdateInputDto,
 ) => {
      
      
      return customInstance<TenantDto>(
      {url: `/tenants/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: tenantUpdateInputDto
    },
      );
    }
  


export const getUpdateTenantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTenant>>, TError,{uid: string;data: TenantUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateTenant>>, TError,{uid: string;data: TenantUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateTenant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTenant>>, {uid: string;data: TenantUpdateInputDto}> = (props) => {
          const {uid,data} = props ?? {};

          return  updateTenant(uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTenantMutationResult = NonNullable<Awaited<ReturnType<typeof updateTenant>>>
    export type UpdateTenantMutationBody = TenantUpdateInputDto
    export type UpdateTenantMutationError = unknown

    /**
 * @summary テナントを更新
 */
export const useUpdateTenant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTenant>>, TError,{uid: string;data: TenantUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateTenant>>,
        TError,
        {uid: string;data: TenantUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateTenantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary テナントを削除
 */
export const deleteTenant = (
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/tenants/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteTenantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTenant>>, TError,{uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteTenant>>, TError,{uid: string}, TContext> => {
    
const mutationKey = ['deleteTenant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTenant>>, {uid: string}> = (props) => {
          const {uid} = props ?? {};

          return  deleteTenant(uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTenantMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTenant>>>
    
    export type DeleteTenantMutationError = unknown

    /**
 * @summary テナントを削除
 */
export const useDeleteTenant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTenant>>, TError,{uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteTenant>>,
        TError,
        {uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteTenantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary テナント内の利用者一覧を取得
 */
export const getResidents = (
    tenantUid?: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResidentListResponseDto>(
      {url: `/tenants/${tenantUid}/residents`, method: 'GET', signal
    },
      );
    }
  

export const getGetResidentsQueryKey = (tenantUid?: string,) => {
    return [`/tenants/${tenantUid}/residents`] as const;
    }

    
export const getGetResidentsQueryOptions = <TData = Awaited<ReturnType<typeof getResidents>>, TError = unknown>(tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetResidentsQueryKey(tenantUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getResidents>>> = ({ signal }) => getResidents(tenantUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(tenantUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetResidentsQueryResult = NonNullable<Awaited<ReturnType<typeof getResidents>>>
export type GetResidentsQueryError = unknown


export function useGetResidents<TData = Awaited<ReturnType<typeof getResidents>>, TError = unknown>(
 tenantUid: undefined |  string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResidents>>,
          TError,
          Awaited<ReturnType<typeof getResidents>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResidents<TData = Awaited<ReturnType<typeof getResidents>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResidents>>,
          TError,
          Awaited<ReturnType<typeof getResidents>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResidents<TData = Awaited<ReturnType<typeof getResidents>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary テナント内の利用者一覧を取得
 */

export function useGetResidents<TData = Awaited<ReturnType<typeof getResidents>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResidents>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetResidentsQueryOptions(tenantUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary テナントに利用者を作成
 */
export const createResident = (
    tenantUid: string,
    residentCreateInputDto: ResidentCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResidentDto>(
      {url: `/tenants/${tenantUid}/residents`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: residentCreateInputDto, signal
    },
      );
    }
  


export const getCreateResidentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createResident>>, TError,{tenantUid: string;data: ResidentCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createResident>>, TError,{tenantUid: string;data: ResidentCreateInputDto}, TContext> => {
    
const mutationKey = ['createResident'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createResident>>, {tenantUid: string;data: ResidentCreateInputDto}> = (props) => {
          const {tenantUid,data} = props ?? {};

          return  createResident(tenantUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateResidentMutationResult = NonNullable<Awaited<ReturnType<typeof createResident>>>
    export type CreateResidentMutationBody = ResidentCreateInputDto
    export type CreateResidentMutationError = unknown

    /**
 * @summary テナントに利用者を作成
 */
export const useCreateResident = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createResident>>, TError,{tenantUid: string;data: ResidentCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createResident>>,
        TError,
        {tenantUid: string;data: ResidentCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateResidentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の詳細を取得
 */
export const getResident = (
    tenantUid: string,
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ResidentDto>(
      {url: `/tenants/${tenantUid}/residents/${uid}`, method: 'GET', signal
    },
      );
    }
  

export const getGetResidentQueryKey = (tenantUid: string,
    uid: string,) => {
    return [`/tenants/${tenantUid}/residents/${uid}`] as const;
    }

    
export const getGetResidentQueryOptions = <TData = Awaited<ReturnType<typeof getResident>>, TError = unknown>(tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetResidentQueryKey(tenantUid,uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getResident>>> = ({ signal }) => getResident(tenantUid,uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(tenantUid && uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetResidentQueryResult = NonNullable<Awaited<ReturnType<typeof getResident>>>
export type GetResidentQueryError = unknown


export function useGetResident<TData = Awaited<ReturnType<typeof getResident>>, TError = unknown>(
 tenantUid: string,
    uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResident>>,
          TError,
          Awaited<ReturnType<typeof getResident>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResident<TData = Awaited<ReturnType<typeof getResident>>, TError = unknown>(
 tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getResident>>,
          TError,
          Awaited<ReturnType<typeof getResident>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetResident<TData = Awaited<ReturnType<typeof getResident>>, TError = unknown>(
 tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の詳細を取得
 */

export function useGetResident<TData = Awaited<ReturnType<typeof getResident>>, TError = unknown>(
 tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getResident>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetResidentQueryOptions(tenantUid,uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 利用者を更新
 */
export const updateResident = (
    tenantUid: string,
    uid: string,
    residentUpdateInputDto: ResidentUpdateInputDto,
 ) => {
      
      
      return customInstance<ResidentDto>(
      {url: `/tenants/${tenantUid}/residents/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: residentUpdateInputDto
    },
      );
    }
  


export const getUpdateResidentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateResident>>, TError,{tenantUid: string;uid: string;data: ResidentUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateResident>>, TError,{tenantUid: string;uid: string;data: ResidentUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateResident'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateResident>>, {tenantUid: string;uid: string;data: ResidentUpdateInputDto}> = (props) => {
          const {tenantUid,uid,data} = props ?? {};

          return  updateResident(tenantUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateResidentMutationResult = NonNullable<Awaited<ReturnType<typeof updateResident>>>
    export type UpdateResidentMutationBody = ResidentUpdateInputDto
    export type UpdateResidentMutationError = unknown

    /**
 * @summary 利用者を更新
 */
export const useUpdateResident = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateResident>>, TError,{tenantUid: string;uid: string;data: ResidentUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateResident>>,
        TError,
        {tenantUid: string;uid: string;data: ResidentUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateResidentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者を削除
 */
export const deleteResident = (
    tenantUid: string,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/tenants/${tenantUid}/residents/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteResidentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteResident>>, TError,{tenantUid: string;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteResident>>, TError,{tenantUid: string;uid: string}, TContext> => {
    
const mutationKey = ['deleteResident'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteResident>>, {tenantUid: string;uid: string}> = (props) => {
          const {tenantUid,uid} = props ?? {};

          return  deleteResident(tenantUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteResidentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteResident>>>
    
    export type DeleteResidentMutationError = unknown

    /**
 * @summary 利用者を削除
 */
export const useDeleteResident = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteResident>>, TError,{tenantUid: string;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteResident>>,
        TError,
        {tenantUid: string;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteResidentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の食事記録一覧を取得
 */
export const getFoodRecords = (
    residentUid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<FoodRecordListResponseDto>(
      {url: `/residents/${residentUid}/food-records`, method: 'GET', signal
    },
      );
    }
  

export const getGetFoodRecordsQueryKey = (residentUid: string,) => {
    return [`/residents/${residentUid}/food-records`] as const;
    }

    
export const getGetFoodRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getFoodRecords>>, TError = unknown>(residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFoodRecordsQueryKey(residentUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFoodRecords>>> = ({ signal }) => getFoodRecords(residentUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFoodRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getFoodRecords>>>
export type GetFoodRecordsQueryError = unknown


export function useGetFoodRecords<TData = Awaited<ReturnType<typeof getFoodRecords>>, TError = unknown>(
 residentUid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFoodRecords>>,
          TError,
          Awaited<ReturnType<typeof getFoodRecords>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoodRecords<TData = Awaited<ReturnType<typeof getFoodRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFoodRecords>>,
          TError,
          Awaited<ReturnType<typeof getFoodRecords>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoodRecords<TData = Awaited<ReturnType<typeof getFoodRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の食事記録一覧を取得
 */

export function useGetFoodRecords<TData = Awaited<ReturnType<typeof getFoodRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFoodRecordsQueryOptions(residentUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 食事記録を作成
 */
export const createFoodRecord = (
    residentUid: string,
    foodRecordCreateInputDto: FoodRecordCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<FoodRecordDto>(
      {url: `/residents/${residentUid}/food-records`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: foodRecordCreateInputDto, signal
    },
      );
    }
  


export const getCreateFoodRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFoodRecord>>, TError,{residentUid: string;data: FoodRecordCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createFoodRecord>>, TError,{residentUid: string;data: FoodRecordCreateInputDto}, TContext> => {
    
const mutationKey = ['createFoodRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createFoodRecord>>, {residentUid: string;data: FoodRecordCreateInputDto}> = (props) => {
          const {residentUid,data} = props ?? {};

          return  createFoodRecord(residentUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateFoodRecordMutationResult = NonNullable<Awaited<ReturnType<typeof createFoodRecord>>>
    export type CreateFoodRecordMutationBody = FoodRecordCreateInputDto
    export type CreateFoodRecordMutationError = unknown

    /**
 * @summary 食事記録を作成
 */
export const useCreateFoodRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFoodRecord>>, TError,{residentUid: string;data: FoodRecordCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createFoodRecord>>,
        TError,
        {residentUid: string;data: FoodRecordCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateFoodRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の日別食事記録一覧を取得
 */
export const getDailyFoodRecords = (
    residentUid: string,
    params?: GetDailyFoodRecordsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<DailyFoodRecordsListResponseDto>(
      {url: `/residents/${residentUid}/food-records/daily`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetDailyFoodRecordsQueryKey = (residentUid: string,
    params?: GetDailyFoodRecordsParams,) => {
    return [`/residents/${residentUid}/food-records/daily`, ...(params ? [params]: [])] as const;
    }

    
export const getGetDailyFoodRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getDailyFoodRecords>>, TError = unknown>(residentUid: string,
    params?: GetDailyFoodRecordsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyFoodRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDailyFoodRecordsQueryKey(residentUid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDailyFoodRecords>>> = ({ signal }) => getDailyFoodRecords(residentUid,params, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDailyFoodRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDailyFoodRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getDailyFoodRecords>>>
export type GetDailyFoodRecordsQueryError = unknown


export function useGetDailyFoodRecords<TData = Awaited<ReturnType<typeof getDailyFoodRecords>>, TError = unknown>(
 residentUid: string,
    params: undefined |  GetDailyFoodRecordsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyFoodRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDailyFoodRecords>>,
          TError,
          Awaited<ReturnType<typeof getDailyFoodRecords>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDailyFoodRecords<TData = Awaited<ReturnType<typeof getDailyFoodRecords>>, TError = unknown>(
 residentUid: string,
    params?: GetDailyFoodRecordsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyFoodRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDailyFoodRecords>>,
          TError,
          Awaited<ReturnType<typeof getDailyFoodRecords>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDailyFoodRecords<TData = Awaited<ReturnType<typeof getDailyFoodRecords>>, TError = unknown>(
 residentUid: string,
    params?: GetDailyFoodRecordsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyFoodRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の日別食事記録一覧を取得
 */

export function useGetDailyFoodRecords<TData = Awaited<ReturnType<typeof getDailyFoodRecords>>, TError = unknown>(
 residentUid: string,
    params?: GetDailyFoodRecordsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyFoodRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDailyFoodRecordsQueryOptions(residentUid,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 食事記録を更新
 */
export const updateFoodRecord = (
    residentUid: unknown,
    uid: string,
    foodRecordUpdateInputDto: FoodRecordUpdateInputDto,
 ) => {
      
      
      return customInstance<FoodRecordDto>(
      {url: `/residents/${residentUid}/food-records/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: foodRecordUpdateInputDto
    },
      );
    }
  


export const getUpdateFoodRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFoodRecord>>, TError,{residentUid: unknown;uid: string;data: FoodRecordUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateFoodRecord>>, TError,{residentUid: unknown;uid: string;data: FoodRecordUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateFoodRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateFoodRecord>>, {residentUid: unknown;uid: string;data: FoodRecordUpdateInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateFoodRecord(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateFoodRecordMutationResult = NonNullable<Awaited<ReturnType<typeof updateFoodRecord>>>
    export type UpdateFoodRecordMutationBody = FoodRecordUpdateInputDto
    export type UpdateFoodRecordMutationError = unknown

    /**
 * @summary 食事記録を更新
 */
export const useUpdateFoodRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFoodRecord>>, TError,{residentUid: unknown;uid: string;data: FoodRecordUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateFoodRecord>>,
        TError,
        {residentUid: unknown;uid: string;data: FoodRecordUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateFoodRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 食事記録を削除
 */
export const deleteFoodRecord = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/food-records/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteFoodRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteFoodRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteFoodRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteFoodRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteFoodRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteFoodRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteFoodRecordMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFoodRecord>>>
    
    export type DeleteFoodRecordMutationError = unknown

    /**
 * @summary 食事記録を削除
 */
export const useDeleteFoodRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteFoodRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteFoodRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteFoodRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 食事記録の文字起こしを取得
 */
export const getFoodRecordTranscription = (
    residentUid: unknown,
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/residents/${residentUid}/food-records/${uid}/transcription`, method: 'GET', signal
    },
      );
    }
  

export const getGetFoodRecordTranscriptionQueryKey = (residentUid: unknown,
    uid: string,) => {
    return [`/residents/${residentUid}/food-records/${uid}/transcription`] as const;
    }

    
export const getGetFoodRecordTranscriptionQueryOptions = <TData = Awaited<ReturnType<typeof getFoodRecordTranscription>>, TError = unknown>(residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecordTranscription>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFoodRecordTranscriptionQueryKey(residentUid,uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFoodRecordTranscription>>> = ({ signal }) => getFoodRecordTranscription(residentUid,uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid && uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFoodRecordTranscription>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFoodRecordTranscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof getFoodRecordTranscription>>>
export type GetFoodRecordTranscriptionQueryError = unknown


export function useGetFoodRecordTranscription<TData = Awaited<ReturnType<typeof getFoodRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecordTranscription>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFoodRecordTranscription>>,
          TError,
          Awaited<ReturnType<typeof getFoodRecordTranscription>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoodRecordTranscription<TData = Awaited<ReturnType<typeof getFoodRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecordTranscription>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFoodRecordTranscription>>,
          TError,
          Awaited<ReturnType<typeof getFoodRecordTranscription>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFoodRecordTranscription<TData = Awaited<ReturnType<typeof getFoodRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecordTranscription>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 食事記録の文字起こしを取得
 */

export function useGetFoodRecordTranscription<TData = Awaited<ReturnType<typeof getFoodRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFoodRecordTranscription>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFoodRecordTranscriptionQueryOptions(residentUid,uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 食事記録の文字起こしを追記
 */
export const appendFoodRecordTranscription = (
    residentUid: unknown,
    uid: string,
    transcriptionInputDto: TranscriptionInputDto,
 ) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/residents/${residentUid}/food-records/${uid}/transcription`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: transcriptionInputDto
    },
      );
    }
  


export const getAppendFoodRecordTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appendFoodRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appendFoodRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext> => {
    
const mutationKey = ['appendFoodRecordTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appendFoodRecordTranscription>>, {residentUid: unknown;uid: string;data: TranscriptionInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  appendFoodRecordTranscription(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppendFoodRecordTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof appendFoodRecordTranscription>>>
    export type AppendFoodRecordTranscriptionMutationBody = TranscriptionInputDto
    export type AppendFoodRecordTranscriptionMutationError = unknown

    /**
 * @summary 食事記録の文字起こしを追記
 */
export const useAppendFoodRecordTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appendFoodRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof appendFoodRecordTranscription>>,
        TError,
        {residentUid: unknown;uid: string;data: TranscriptionInputDto},
        TContext
      > => {

      const mutationOptions = getAppendFoodRecordTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 食事記録の文字起こしを置換
 */
export const updateFoodRecordTranscription = (
    residentUid: unknown,
    uid: string,
    transcriptionInputDto: TranscriptionInputDto,
 ) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/residents/${residentUid}/food-records/${uid}/transcription`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: transcriptionInputDto
    },
      );
    }
  


export const getUpdateFoodRecordTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFoodRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateFoodRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext> => {
    
const mutationKey = ['updateFoodRecordTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateFoodRecordTranscription>>, {residentUid: unknown;uid: string;data: TranscriptionInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateFoodRecordTranscription(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateFoodRecordTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof updateFoodRecordTranscription>>>
    export type UpdateFoodRecordTranscriptionMutationBody = TranscriptionInputDto
    export type UpdateFoodRecordTranscriptionMutationError = unknown

    /**
 * @summary 食事記録の文字起こしを置換
 */
export const useUpdateFoodRecordTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFoodRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateFoodRecordTranscription>>,
        TError,
        {residentUid: unknown;uid: string;data: TranscriptionInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateFoodRecordTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 食事記録の文字起こしを削除
 */
export const deleteFoodRecordTranscription = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/food-records/${uid}/transcription`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteFoodRecordTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteFoodRecordTranscription>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteFoodRecordTranscription>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteFoodRecordTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteFoodRecordTranscription>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteFoodRecordTranscription(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteFoodRecordTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFoodRecordTranscription>>>
    
    export type DeleteFoodRecordTranscriptionMutationError = unknown

    /**
 * @summary 食事記録の文字起こしを削除
 */
export const useDeleteFoodRecordTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteFoodRecordTranscription>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteFoodRecordTranscription>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteFoodRecordTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 食事記録から情報を抽出
 */
export const extractFoodRecord = (
    residentUid: unknown,
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<FoodRecordExtractedDto>(
      {url: `/residents/${residentUid}/food-records/${uid}/extract`, method: 'POST', signal
    },
      );
    }
  


export const getExtractFoodRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractFoodRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof extractFoodRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['extractFoodRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof extractFoodRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  extractFoodRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExtractFoodRecordMutationResult = NonNullable<Awaited<ReturnType<typeof extractFoodRecord>>>
    
    export type ExtractFoodRecordMutationError = unknown

    /**
 * @summary 食事記録から情報を抽出
 */
export const useExtractFoodRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractFoodRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof extractFoodRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getExtractFoodRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の入浴記録一覧を取得
 */
export const getBathRecords = (
    residentUid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BathRecordListResponseDto>(
      {url: `/residents/${residentUid}/bath-records`, method: 'GET', signal
    },
      );
    }
  

export const getGetBathRecordsQueryKey = (residentUid: string,) => {
    return [`/residents/${residentUid}/bath-records`] as const;
    }

    
export const getGetBathRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getBathRecords>>, TError = unknown>(residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBathRecordsQueryKey(residentUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBathRecords>>> = ({ signal }) => getBathRecords(residentUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBathRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getBathRecords>>>
export type GetBathRecordsQueryError = unknown


export function useGetBathRecords<TData = Awaited<ReturnType<typeof getBathRecords>>, TError = unknown>(
 residentUid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBathRecords>>,
          TError,
          Awaited<ReturnType<typeof getBathRecords>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBathRecords<TData = Awaited<ReturnType<typeof getBathRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBathRecords>>,
          TError,
          Awaited<ReturnType<typeof getBathRecords>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBathRecords<TData = Awaited<ReturnType<typeof getBathRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の入浴記録一覧を取得
 */

export function useGetBathRecords<TData = Awaited<ReturnType<typeof getBathRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBathRecordsQueryOptions(residentUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 入浴記録を作成
 */
export const createBathRecord = (
    residentUid: string,
    bathRecordCreateInputDto: BathRecordCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BathRecordDto>(
      {url: `/residents/${residentUid}/bath-records`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bathRecordCreateInputDto, signal
    },
      );
    }
  


export const getCreateBathRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBathRecord>>, TError,{residentUid: string;data: BathRecordCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createBathRecord>>, TError,{residentUid: string;data: BathRecordCreateInputDto}, TContext> => {
    
const mutationKey = ['createBathRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBathRecord>>, {residentUid: string;data: BathRecordCreateInputDto}> = (props) => {
          const {residentUid,data} = props ?? {};

          return  createBathRecord(residentUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBathRecordMutationResult = NonNullable<Awaited<ReturnType<typeof createBathRecord>>>
    export type CreateBathRecordMutationBody = BathRecordCreateInputDto
    export type CreateBathRecordMutationError = unknown

    /**
 * @summary 入浴記録を作成
 */
export const useCreateBathRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBathRecord>>, TError,{residentUid: string;data: BathRecordCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createBathRecord>>,
        TError,
        {residentUid: string;data: BathRecordCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateBathRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 入浴記録を更新
 */
export const updateBathRecord = (
    residentUid: unknown,
    uid: string,
    bathRecordUpdateInputDto: BathRecordUpdateInputDto,
 ) => {
      
      
      return customInstance<BathRecordDto>(
      {url: `/residents/${residentUid}/bath-records/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: bathRecordUpdateInputDto
    },
      );
    }
  


export const getUpdateBathRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBathRecord>>, TError,{residentUid: unknown;uid: string;data: BathRecordUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBathRecord>>, TError,{residentUid: unknown;uid: string;data: BathRecordUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateBathRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBathRecord>>, {residentUid: unknown;uid: string;data: BathRecordUpdateInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateBathRecord(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBathRecordMutationResult = NonNullable<Awaited<ReturnType<typeof updateBathRecord>>>
    export type UpdateBathRecordMutationBody = BathRecordUpdateInputDto
    export type UpdateBathRecordMutationError = unknown

    /**
 * @summary 入浴記録を更新
 */
export const useUpdateBathRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBathRecord>>, TError,{residentUid: unknown;uid: string;data: BathRecordUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateBathRecord>>,
        TError,
        {residentUid: unknown;uid: string;data: BathRecordUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateBathRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 入浴記録を削除
 */
export const deleteBathRecord = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/bath-records/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBathRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBathRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteBathRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteBathRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBathRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteBathRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBathRecordMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBathRecord>>>
    
    export type DeleteBathRecordMutationError = unknown

    /**
 * @summary 入浴記録を削除
 */
export const useDeleteBathRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBathRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteBathRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteBathRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 入浴記録の文字起こしを取得
 */
export const getBathRecordTranscription = (
    residentUid: unknown,
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/residents/${residentUid}/bath-records/${uid}/transcription`, method: 'GET', signal
    },
      );
    }
  

export const getGetBathRecordTranscriptionQueryKey = (residentUid: unknown,
    uid: string,) => {
    return [`/residents/${residentUid}/bath-records/${uid}/transcription`] as const;
    }

    
export const getGetBathRecordTranscriptionQueryOptions = <TData = Awaited<ReturnType<typeof getBathRecordTranscription>>, TError = unknown>(residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecordTranscription>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBathRecordTranscriptionQueryKey(residentUid,uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBathRecordTranscription>>> = ({ signal }) => getBathRecordTranscription(residentUid,uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid && uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBathRecordTranscription>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBathRecordTranscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof getBathRecordTranscription>>>
export type GetBathRecordTranscriptionQueryError = unknown


export function useGetBathRecordTranscription<TData = Awaited<ReturnType<typeof getBathRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecordTranscription>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBathRecordTranscription>>,
          TError,
          Awaited<ReturnType<typeof getBathRecordTranscription>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBathRecordTranscription<TData = Awaited<ReturnType<typeof getBathRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecordTranscription>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBathRecordTranscription>>,
          TError,
          Awaited<ReturnType<typeof getBathRecordTranscription>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBathRecordTranscription<TData = Awaited<ReturnType<typeof getBathRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecordTranscription>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 入浴記録の文字起こしを取得
 */

export function useGetBathRecordTranscription<TData = Awaited<ReturnType<typeof getBathRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBathRecordTranscription>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBathRecordTranscriptionQueryOptions(residentUid,uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 入浴記録の文字起こしを追記
 */
export const appendBathRecordTranscription = (
    residentUid: unknown,
    uid: string,
    transcriptionInputDto: TranscriptionInputDto,
 ) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/residents/${residentUid}/bath-records/${uid}/transcription`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: transcriptionInputDto
    },
      );
    }
  


export const getAppendBathRecordTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appendBathRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appendBathRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext> => {
    
const mutationKey = ['appendBathRecordTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appendBathRecordTranscription>>, {residentUid: unknown;uid: string;data: TranscriptionInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  appendBathRecordTranscription(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppendBathRecordTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof appendBathRecordTranscription>>>
    export type AppendBathRecordTranscriptionMutationBody = TranscriptionInputDto
    export type AppendBathRecordTranscriptionMutationError = unknown

    /**
 * @summary 入浴記録の文字起こしを追記
 */
export const useAppendBathRecordTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appendBathRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof appendBathRecordTranscription>>,
        TError,
        {residentUid: unknown;uid: string;data: TranscriptionInputDto},
        TContext
      > => {

      const mutationOptions = getAppendBathRecordTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 入浴記録の文字起こしを置換
 */
export const updateBathRecordTranscription = (
    residentUid: unknown,
    uid: string,
    transcriptionInputDto: TranscriptionInputDto,
 ) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/residents/${residentUid}/bath-records/${uid}/transcription`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: transcriptionInputDto
    },
      );
    }
  


export const getUpdateBathRecordTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBathRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBathRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext> => {
    
const mutationKey = ['updateBathRecordTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBathRecordTranscription>>, {residentUid: unknown;uid: string;data: TranscriptionInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateBathRecordTranscription(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBathRecordTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof updateBathRecordTranscription>>>
    export type UpdateBathRecordTranscriptionMutationBody = TranscriptionInputDto
    export type UpdateBathRecordTranscriptionMutationError = unknown

    /**
 * @summary 入浴記録の文字起こしを置換
 */
export const useUpdateBathRecordTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBathRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateBathRecordTranscription>>,
        TError,
        {residentUid: unknown;uid: string;data: TranscriptionInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateBathRecordTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 入浴記録の文字起こしを削除
 */
export const deleteBathRecordTranscription = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/bath-records/${uid}/transcription`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBathRecordTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBathRecordTranscription>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteBathRecordTranscription>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteBathRecordTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBathRecordTranscription>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteBathRecordTranscription(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBathRecordTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBathRecordTranscription>>>
    
    export type DeleteBathRecordTranscriptionMutationError = unknown

    /**
 * @summary 入浴記録の文字起こしを削除
 */
export const useDeleteBathRecordTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBathRecordTranscription>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteBathRecordTranscription>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteBathRecordTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 入浴記録から情報を抽出
 */
export const extractBathRecord = (
    residentUid: unknown,
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BathRecordExtractedDto>(
      {url: `/residents/${residentUid}/bath-records/${uid}/extract`, method: 'POST', signal
    },
      );
    }
  


export const getExtractBathRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractBathRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof extractBathRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['extractBathRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof extractBathRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  extractBathRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExtractBathRecordMutationResult = NonNullable<Awaited<ReturnType<typeof extractBathRecord>>>
    
    export type ExtractBathRecordMutationError = unknown

    /**
 * @summary 入浴記録から情報を抽出
 */
export const useExtractBathRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractBathRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof extractBathRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getExtractBathRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の排泄記録一覧を取得
 */
export const getEliminationRecords = (
    residentUid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<EliminationRecordListResponseDto>(
      {url: `/residents/${residentUid}/elimination-records`, method: 'GET', signal
    },
      );
    }
  

export const getGetEliminationRecordsQueryKey = (residentUid: string,) => {
    return [`/residents/${residentUid}/elimination-records`] as const;
    }

    
export const getGetEliminationRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getEliminationRecords>>, TError = unknown>(residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEliminationRecordsQueryKey(residentUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEliminationRecords>>> = ({ signal }) => getEliminationRecords(residentUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEliminationRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getEliminationRecords>>>
export type GetEliminationRecordsQueryError = unknown


export function useGetEliminationRecords<TData = Awaited<ReturnType<typeof getEliminationRecords>>, TError = unknown>(
 residentUid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEliminationRecords>>,
          TError,
          Awaited<ReturnType<typeof getEliminationRecords>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEliminationRecords<TData = Awaited<ReturnType<typeof getEliminationRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEliminationRecords>>,
          TError,
          Awaited<ReturnType<typeof getEliminationRecords>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEliminationRecords<TData = Awaited<ReturnType<typeof getEliminationRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の排泄記録一覧を取得
 */

export function useGetEliminationRecords<TData = Awaited<ReturnType<typeof getEliminationRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEliminationRecordsQueryOptions(residentUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 排泄記録を作成
 */
export const createEliminationRecord = (
    residentUid: string,
    eliminationRecordCreateInputDto: EliminationRecordCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<EliminationRecordDto>(
      {url: `/residents/${residentUid}/elimination-records`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: eliminationRecordCreateInputDto, signal
    },
      );
    }
  


export const getCreateEliminationRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEliminationRecord>>, TError,{residentUid: string;data: EliminationRecordCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createEliminationRecord>>, TError,{residentUid: string;data: EliminationRecordCreateInputDto}, TContext> => {
    
const mutationKey = ['createEliminationRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createEliminationRecord>>, {residentUid: string;data: EliminationRecordCreateInputDto}> = (props) => {
          const {residentUid,data} = props ?? {};

          return  createEliminationRecord(residentUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateEliminationRecordMutationResult = NonNullable<Awaited<ReturnType<typeof createEliminationRecord>>>
    export type CreateEliminationRecordMutationBody = EliminationRecordCreateInputDto
    export type CreateEliminationRecordMutationError = unknown

    /**
 * @summary 排泄記録を作成
 */
export const useCreateEliminationRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEliminationRecord>>, TError,{residentUid: string;data: EliminationRecordCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createEliminationRecord>>,
        TError,
        {residentUid: string;data: EliminationRecordCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateEliminationRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 排泄記録を更新
 */
export const updateEliminationRecord = (
    residentUid: unknown,
    uid: string,
    eliminationRecordUpdateInputDto: EliminationRecordUpdateInputDto,
 ) => {
      
      
      return customInstance<EliminationRecordDto>(
      {url: `/residents/${residentUid}/elimination-records/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: eliminationRecordUpdateInputDto
    },
      );
    }
  


export const getUpdateEliminationRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEliminationRecord>>, TError,{residentUid: unknown;uid: string;data: EliminationRecordUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateEliminationRecord>>, TError,{residentUid: unknown;uid: string;data: EliminationRecordUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateEliminationRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEliminationRecord>>, {residentUid: unknown;uid: string;data: EliminationRecordUpdateInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateEliminationRecord(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateEliminationRecordMutationResult = NonNullable<Awaited<ReturnType<typeof updateEliminationRecord>>>
    export type UpdateEliminationRecordMutationBody = EliminationRecordUpdateInputDto
    export type UpdateEliminationRecordMutationError = unknown

    /**
 * @summary 排泄記録を更新
 */
export const useUpdateEliminationRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEliminationRecord>>, TError,{residentUid: unknown;uid: string;data: EliminationRecordUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateEliminationRecord>>,
        TError,
        {residentUid: unknown;uid: string;data: EliminationRecordUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateEliminationRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 排泄記録を削除
 */
export const deleteEliminationRecord = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/elimination-records/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteEliminationRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEliminationRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteEliminationRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteEliminationRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEliminationRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteEliminationRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteEliminationRecordMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEliminationRecord>>>
    
    export type DeleteEliminationRecordMutationError = unknown

    /**
 * @summary 排泄記録を削除
 */
export const useDeleteEliminationRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEliminationRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteEliminationRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteEliminationRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 排泄記録の文字起こしを取得
 */
export const getEliminationRecordTranscription = (
    residentUid: unknown,
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/residents/${residentUid}/elimination-records/${uid}/transcription`, method: 'GET', signal
    },
      );
    }
  

export const getGetEliminationRecordTranscriptionQueryKey = (residentUid: unknown,
    uid: string,) => {
    return [`/residents/${residentUid}/elimination-records/${uid}/transcription`] as const;
    }

    
export const getGetEliminationRecordTranscriptionQueryOptions = <TData = Awaited<ReturnType<typeof getEliminationRecordTranscription>>, TError = unknown>(residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecordTranscription>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEliminationRecordTranscriptionQueryKey(residentUid,uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEliminationRecordTranscription>>> = ({ signal }) => getEliminationRecordTranscription(residentUid,uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid && uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecordTranscription>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetEliminationRecordTranscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof getEliminationRecordTranscription>>>
export type GetEliminationRecordTranscriptionQueryError = unknown


export function useGetEliminationRecordTranscription<TData = Awaited<ReturnType<typeof getEliminationRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecordTranscription>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEliminationRecordTranscription>>,
          TError,
          Awaited<ReturnType<typeof getEliminationRecordTranscription>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEliminationRecordTranscription<TData = Awaited<ReturnType<typeof getEliminationRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecordTranscription>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEliminationRecordTranscription>>,
          TError,
          Awaited<ReturnType<typeof getEliminationRecordTranscription>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetEliminationRecordTranscription<TData = Awaited<ReturnType<typeof getEliminationRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecordTranscription>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 排泄記録の文字起こしを取得
 */

export function useGetEliminationRecordTranscription<TData = Awaited<ReturnType<typeof getEliminationRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getEliminationRecordTranscription>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetEliminationRecordTranscriptionQueryOptions(residentUid,uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 排泄記録の文字起こしを追記
 */
export const appendEliminationRecordTranscription = (
    residentUid: unknown,
    uid: string,
    transcriptionInputDto: TranscriptionInputDto,
 ) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/residents/${residentUid}/elimination-records/${uid}/transcription`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: transcriptionInputDto
    },
      );
    }
  


export const getAppendEliminationRecordTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appendEliminationRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appendEliminationRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext> => {
    
const mutationKey = ['appendEliminationRecordTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appendEliminationRecordTranscription>>, {residentUid: unknown;uid: string;data: TranscriptionInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  appendEliminationRecordTranscription(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppendEliminationRecordTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof appendEliminationRecordTranscription>>>
    export type AppendEliminationRecordTranscriptionMutationBody = TranscriptionInputDto
    export type AppendEliminationRecordTranscriptionMutationError = unknown

    /**
 * @summary 排泄記録の文字起こしを追記
 */
export const useAppendEliminationRecordTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appendEliminationRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof appendEliminationRecordTranscription>>,
        TError,
        {residentUid: unknown;uid: string;data: TranscriptionInputDto},
        TContext
      > => {

      const mutationOptions = getAppendEliminationRecordTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 排泄記録の文字起こしを置換
 */
export const updateEliminationRecordTranscription = (
    residentUid: unknown,
    uid: string,
    transcriptionInputDto: TranscriptionInputDto,
 ) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/residents/${residentUid}/elimination-records/${uid}/transcription`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: transcriptionInputDto
    },
      );
    }
  


export const getUpdateEliminationRecordTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEliminationRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateEliminationRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext> => {
    
const mutationKey = ['updateEliminationRecordTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEliminationRecordTranscription>>, {residentUid: unknown;uid: string;data: TranscriptionInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateEliminationRecordTranscription(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateEliminationRecordTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof updateEliminationRecordTranscription>>>
    export type UpdateEliminationRecordTranscriptionMutationBody = TranscriptionInputDto
    export type UpdateEliminationRecordTranscriptionMutationError = unknown

    /**
 * @summary 排泄記録の文字起こしを置換
 */
export const useUpdateEliminationRecordTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEliminationRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateEliminationRecordTranscription>>,
        TError,
        {residentUid: unknown;uid: string;data: TranscriptionInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateEliminationRecordTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 排泄記録の文字起こしを削除
 */
export const deleteEliminationRecordTranscription = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/elimination-records/${uid}/transcription`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteEliminationRecordTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEliminationRecordTranscription>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteEliminationRecordTranscription>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteEliminationRecordTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteEliminationRecordTranscription>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteEliminationRecordTranscription(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteEliminationRecordTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteEliminationRecordTranscription>>>
    
    export type DeleteEliminationRecordTranscriptionMutationError = unknown

    /**
 * @summary 排泄記録の文字起こしを削除
 */
export const useDeleteEliminationRecordTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteEliminationRecordTranscription>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteEliminationRecordTranscription>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteEliminationRecordTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 排泄記録から情報を抽出
 */
export const extractEliminationRecord = (
    residentUid: unknown,
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/residents/${residentUid}/elimination-records/${uid}/extract`, method: 'POST', signal
    },
      );
    }
  


export const getExtractEliminationRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractEliminationRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof extractEliminationRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['extractEliminationRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof extractEliminationRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  extractEliminationRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExtractEliminationRecordMutationResult = NonNullable<Awaited<ReturnType<typeof extractEliminationRecord>>>
    
    export type ExtractEliminationRecordMutationError = unknown

    /**
 * @summary 排泄記録から情報を抽出
 */
export const useExtractEliminationRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractEliminationRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof extractEliminationRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getExtractEliminationRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の日常記録一覧を取得
 */
export const getDailyRecords = (
    residentUid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<DailyRecordListResponseDto>(
      {url: `/residents/${residentUid}/daily-records`, method: 'GET', signal
    },
      );
    }
  

export const getGetDailyRecordsQueryKey = (residentUid: string,) => {
    return [`/residents/${residentUid}/daily-records`] as const;
    }

    
export const getGetDailyRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getDailyRecords>>, TError = unknown>(residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDailyRecordsQueryKey(residentUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDailyRecords>>> = ({ signal }) => getDailyRecords(residentUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDailyRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getDailyRecords>>>
export type GetDailyRecordsQueryError = unknown


export function useGetDailyRecords<TData = Awaited<ReturnType<typeof getDailyRecords>>, TError = unknown>(
 residentUid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDailyRecords>>,
          TError,
          Awaited<ReturnType<typeof getDailyRecords>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDailyRecords<TData = Awaited<ReturnType<typeof getDailyRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDailyRecords>>,
          TError,
          Awaited<ReturnType<typeof getDailyRecords>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDailyRecords<TData = Awaited<ReturnType<typeof getDailyRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の日常記録一覧を取得
 */

export function useGetDailyRecords<TData = Awaited<ReturnType<typeof getDailyRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDailyRecordsQueryOptions(residentUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 日常記録を作成
 */
export const createDailyRecord = (
    residentUid: string,
    dailyRecordCreateInputDto: DailyRecordCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<DailyRecordDto>(
      {url: `/residents/${residentUid}/daily-records`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: dailyRecordCreateInputDto, signal
    },
      );
    }
  


export const getCreateDailyRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDailyRecord>>, TError,{residentUid: string;data: DailyRecordCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createDailyRecord>>, TError,{residentUid: string;data: DailyRecordCreateInputDto}, TContext> => {
    
const mutationKey = ['createDailyRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDailyRecord>>, {residentUid: string;data: DailyRecordCreateInputDto}> = (props) => {
          const {residentUid,data} = props ?? {};

          return  createDailyRecord(residentUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDailyRecordMutationResult = NonNullable<Awaited<ReturnType<typeof createDailyRecord>>>
    export type CreateDailyRecordMutationBody = DailyRecordCreateInputDto
    export type CreateDailyRecordMutationError = unknown

    /**
 * @summary 日常記録を作成
 */
export const useCreateDailyRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDailyRecord>>, TError,{residentUid: string;data: DailyRecordCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createDailyRecord>>,
        TError,
        {residentUid: string;data: DailyRecordCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateDailyRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 個別の日常記録を取得
 */
export const getDailyRecord = (
    residentUid: unknown,
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<DailyRecordDto>(
      {url: `/residents/${residentUid}/daily-records/${uid}`, method: 'GET', signal
    },
      );
    }
  

export const getGetDailyRecordQueryKey = (residentUid: unknown,
    uid: string,) => {
    return [`/residents/${residentUid}/daily-records/${uid}`] as const;
    }

    
export const getGetDailyRecordQueryOptions = <TData = Awaited<ReturnType<typeof getDailyRecord>>, TError = unknown>(residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecord>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDailyRecordQueryKey(residentUid,uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDailyRecord>>> = ({ signal }) => getDailyRecord(residentUid,uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid && uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDailyRecord>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDailyRecordQueryResult = NonNullable<Awaited<ReturnType<typeof getDailyRecord>>>
export type GetDailyRecordQueryError = unknown


export function useGetDailyRecord<TData = Awaited<ReturnType<typeof getDailyRecord>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecord>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDailyRecord>>,
          TError,
          Awaited<ReturnType<typeof getDailyRecord>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDailyRecord<TData = Awaited<ReturnType<typeof getDailyRecord>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecord>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDailyRecord>>,
          TError,
          Awaited<ReturnType<typeof getDailyRecord>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDailyRecord<TData = Awaited<ReturnType<typeof getDailyRecord>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecord>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 個別の日常記録を取得
 */

export function useGetDailyRecord<TData = Awaited<ReturnType<typeof getDailyRecord>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecord>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDailyRecordQueryOptions(residentUid,uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 日常記録を更新
 */
export const updateDailyRecord = (
    residentUid: unknown,
    uid: string,
    dailyRecordUpdateInputDto: DailyRecordUpdateInputDto,
 ) => {
      
      
      return customInstance<DailyRecordDto>(
      {url: `/residents/${residentUid}/daily-records/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: dailyRecordUpdateInputDto
    },
      );
    }
  


export const getUpdateDailyRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDailyRecord>>, TError,{residentUid: unknown;uid: string;data: DailyRecordUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateDailyRecord>>, TError,{residentUid: unknown;uid: string;data: DailyRecordUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateDailyRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDailyRecord>>, {residentUid: unknown;uid: string;data: DailyRecordUpdateInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateDailyRecord(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDailyRecordMutationResult = NonNullable<Awaited<ReturnType<typeof updateDailyRecord>>>
    export type UpdateDailyRecordMutationBody = DailyRecordUpdateInputDto
    export type UpdateDailyRecordMutationError = unknown

    /**
 * @summary 日常記録を更新
 */
export const useUpdateDailyRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDailyRecord>>, TError,{residentUid: unknown;uid: string;data: DailyRecordUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateDailyRecord>>,
        TError,
        {residentUid: unknown;uid: string;data: DailyRecordUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateDailyRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 日常記録を削除
 */
export const deleteDailyRecord = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/daily-records/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteDailyRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDailyRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteDailyRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteDailyRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDailyRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteDailyRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDailyRecordMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDailyRecord>>>
    
    export type DeleteDailyRecordMutationError = unknown

    /**
 * @summary 日常記録を削除
 */
export const useDeleteDailyRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDailyRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteDailyRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteDailyRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 日常記録の文字起こしを取得
 */
export const getDailyRecordTranscription = (
    residentUid: unknown,
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/residents/${residentUid}/daily-records/${uid}/transcription`, method: 'GET', signal
    },
      );
    }
  

export const getGetDailyRecordTranscriptionQueryKey = (residentUid: unknown,
    uid: string,) => {
    return [`/residents/${residentUid}/daily-records/${uid}/transcription`] as const;
    }

    
export const getGetDailyRecordTranscriptionQueryOptions = <TData = Awaited<ReturnType<typeof getDailyRecordTranscription>>, TError = unknown>(residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecordTranscription>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDailyRecordTranscriptionQueryKey(residentUid,uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDailyRecordTranscription>>> = ({ signal }) => getDailyRecordTranscription(residentUid,uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid && uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDailyRecordTranscription>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDailyRecordTranscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof getDailyRecordTranscription>>>
export type GetDailyRecordTranscriptionQueryError = unknown


export function useGetDailyRecordTranscription<TData = Awaited<ReturnType<typeof getDailyRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecordTranscription>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDailyRecordTranscription>>,
          TError,
          Awaited<ReturnType<typeof getDailyRecordTranscription>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDailyRecordTranscription<TData = Awaited<ReturnType<typeof getDailyRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecordTranscription>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDailyRecordTranscription>>,
          TError,
          Awaited<ReturnType<typeof getDailyRecordTranscription>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDailyRecordTranscription<TData = Awaited<ReturnType<typeof getDailyRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecordTranscription>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 日常記録の文字起こしを取得
 */

export function useGetDailyRecordTranscription<TData = Awaited<ReturnType<typeof getDailyRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDailyRecordTranscription>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDailyRecordTranscriptionQueryOptions(residentUid,uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 日常記録の文字起こしを追記
 */
export const appendDailyRecordTranscription = (
    residentUid: unknown,
    uid: string,
    transcriptionInputDto: TranscriptionInputDto,
 ) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/residents/${residentUid}/daily-records/${uid}/transcription`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: transcriptionInputDto
    },
      );
    }
  


export const getAppendDailyRecordTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appendDailyRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appendDailyRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext> => {
    
const mutationKey = ['appendDailyRecordTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appendDailyRecordTranscription>>, {residentUid: unknown;uid: string;data: TranscriptionInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  appendDailyRecordTranscription(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppendDailyRecordTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof appendDailyRecordTranscription>>>
    export type AppendDailyRecordTranscriptionMutationBody = TranscriptionInputDto
    export type AppendDailyRecordTranscriptionMutationError = unknown

    /**
 * @summary 日常記録の文字起こしを追記
 */
export const useAppendDailyRecordTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appendDailyRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof appendDailyRecordTranscription>>,
        TError,
        {residentUid: unknown;uid: string;data: TranscriptionInputDto},
        TContext
      > => {

      const mutationOptions = getAppendDailyRecordTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 日常記録の文字起こしを置換
 */
export const updateDailyRecordTranscription = (
    residentUid: unknown,
    uid: string,
    transcriptionInputDto: TranscriptionInputDto,
 ) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/residents/${residentUid}/daily-records/${uid}/transcription`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: transcriptionInputDto
    },
      );
    }
  


export const getUpdateDailyRecordTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDailyRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateDailyRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext> => {
    
const mutationKey = ['updateDailyRecordTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDailyRecordTranscription>>, {residentUid: unknown;uid: string;data: TranscriptionInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateDailyRecordTranscription(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDailyRecordTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof updateDailyRecordTranscription>>>
    export type UpdateDailyRecordTranscriptionMutationBody = TranscriptionInputDto
    export type UpdateDailyRecordTranscriptionMutationError = unknown

    /**
 * @summary 日常記録の文字起こしを置換
 */
export const useUpdateDailyRecordTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDailyRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateDailyRecordTranscription>>,
        TError,
        {residentUid: unknown;uid: string;data: TranscriptionInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateDailyRecordTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 日常記録の文字起こしを削除
 */
export const deleteDailyRecordTranscription = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/daily-records/${uid}/transcription`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteDailyRecordTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDailyRecordTranscription>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteDailyRecordTranscription>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteDailyRecordTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDailyRecordTranscription>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteDailyRecordTranscription(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDailyRecordTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDailyRecordTranscription>>>
    
    export type DeleteDailyRecordTranscriptionMutationError = unknown

    /**
 * @summary 日常記録の文字起こしを削除
 */
export const useDeleteDailyRecordTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDailyRecordTranscription>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteDailyRecordTranscription>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteDailyRecordTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 利用者の飲料記録一覧を取得
 */
export const getBeverageRecords = (
    residentUid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BeverageRecordListResponseDto>(
      {url: `/residents/${residentUid}/beverage-records`, method: 'GET', signal
    },
      );
    }
  

export const getGetBeverageRecordsQueryKey = (residentUid: string,) => {
    return [`/residents/${residentUid}/beverage-records`] as const;
    }

    
export const getGetBeverageRecordsQueryOptions = <TData = Awaited<ReturnType<typeof getBeverageRecords>>, TError = unknown>(residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBeverageRecordsQueryKey(residentUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBeverageRecords>>> = ({ signal }) => getBeverageRecords(residentUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBeverageRecordsQueryResult = NonNullable<Awaited<ReturnType<typeof getBeverageRecords>>>
export type GetBeverageRecordsQueryError = unknown


export function useGetBeverageRecords<TData = Awaited<ReturnType<typeof getBeverageRecords>>, TError = unknown>(
 residentUid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBeverageRecords>>,
          TError,
          Awaited<ReturnType<typeof getBeverageRecords>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBeverageRecords<TData = Awaited<ReturnType<typeof getBeverageRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBeverageRecords>>,
          TError,
          Awaited<ReturnType<typeof getBeverageRecords>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBeverageRecords<TData = Awaited<ReturnType<typeof getBeverageRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 利用者の飲料記録一覧を取得
 */

export function useGetBeverageRecords<TData = Awaited<ReturnType<typeof getBeverageRecords>>, TError = unknown>(
 residentUid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecords>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBeverageRecordsQueryOptions(residentUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 飲料記録を作成
 */
export const createBeverageRecord = (
    residentUid: string,
    beverageRecordCreateInputDto: BeverageRecordCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BeverageRecordDto>(
      {url: `/residents/${residentUid}/beverage-records`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: beverageRecordCreateInputDto, signal
    },
      );
    }
  


export const getCreateBeverageRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBeverageRecord>>, TError,{residentUid: string;data: BeverageRecordCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createBeverageRecord>>, TError,{residentUid: string;data: BeverageRecordCreateInputDto}, TContext> => {
    
const mutationKey = ['createBeverageRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBeverageRecord>>, {residentUid: string;data: BeverageRecordCreateInputDto}> = (props) => {
          const {residentUid,data} = props ?? {};

          return  createBeverageRecord(residentUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBeverageRecordMutationResult = NonNullable<Awaited<ReturnType<typeof createBeverageRecord>>>
    export type CreateBeverageRecordMutationBody = BeverageRecordCreateInputDto
    export type CreateBeverageRecordMutationError = unknown

    /**
 * @summary 飲料記録を作成
 */
export const useCreateBeverageRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBeverageRecord>>, TError,{residentUid: string;data: BeverageRecordCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createBeverageRecord>>,
        TError,
        {residentUid: string;data: BeverageRecordCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateBeverageRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 飲料記録を更新
 */
export const updateBeverageRecord = (
    residentUid: unknown,
    uid: string,
    beverageRecordUpdateInputDto: BeverageRecordUpdateInputDto,
 ) => {
      
      
      return customInstance<BeverageRecordDto>(
      {url: `/residents/${residentUid}/beverage-records/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: beverageRecordUpdateInputDto
    },
      );
    }
  


export const getUpdateBeverageRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBeverageRecord>>, TError,{residentUid: unknown;uid: string;data: BeverageRecordUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBeverageRecord>>, TError,{residentUid: unknown;uid: string;data: BeverageRecordUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateBeverageRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBeverageRecord>>, {residentUid: unknown;uid: string;data: BeverageRecordUpdateInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateBeverageRecord(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBeverageRecordMutationResult = NonNullable<Awaited<ReturnType<typeof updateBeverageRecord>>>
    export type UpdateBeverageRecordMutationBody = BeverageRecordUpdateInputDto
    export type UpdateBeverageRecordMutationError = unknown

    /**
 * @summary 飲料記録を更新
 */
export const useUpdateBeverageRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBeverageRecord>>, TError,{residentUid: unknown;uid: string;data: BeverageRecordUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateBeverageRecord>>,
        TError,
        {residentUid: unknown;uid: string;data: BeverageRecordUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateBeverageRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 飲料記録を削除
 */
export const deleteBeverageRecord = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/beverage-records/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBeverageRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBeverageRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteBeverageRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteBeverageRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBeverageRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteBeverageRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBeverageRecordMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBeverageRecord>>>
    
    export type DeleteBeverageRecordMutationError = unknown

    /**
 * @summary 飲料記録を削除
 */
export const useDeleteBeverageRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBeverageRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteBeverageRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteBeverageRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 飲料記録の文字起こしを取得
 */
export const getBeverageRecordTranscription = (
    residentUid: unknown,
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/residents/${residentUid}/beverage-records/${uid}/transcription`, method: 'GET', signal
    },
      );
    }
  

export const getGetBeverageRecordTranscriptionQueryKey = (residentUid: unknown,
    uid: string,) => {
    return [`/residents/${residentUid}/beverage-records/${uid}/transcription`] as const;
    }

    
export const getGetBeverageRecordTranscriptionQueryOptions = <TData = Awaited<ReturnType<typeof getBeverageRecordTranscription>>, TError = unknown>(residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecordTranscription>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBeverageRecordTranscriptionQueryKey(residentUid,uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBeverageRecordTranscription>>> = ({ signal }) => getBeverageRecordTranscription(residentUid,uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(residentUid && uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecordTranscription>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBeverageRecordTranscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof getBeverageRecordTranscription>>>
export type GetBeverageRecordTranscriptionQueryError = unknown


export function useGetBeverageRecordTranscription<TData = Awaited<ReturnType<typeof getBeverageRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecordTranscription>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBeverageRecordTranscription>>,
          TError,
          Awaited<ReturnType<typeof getBeverageRecordTranscription>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBeverageRecordTranscription<TData = Awaited<ReturnType<typeof getBeverageRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecordTranscription>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBeverageRecordTranscription>>,
          TError,
          Awaited<ReturnType<typeof getBeverageRecordTranscription>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBeverageRecordTranscription<TData = Awaited<ReturnType<typeof getBeverageRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecordTranscription>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 飲料記録の文字起こしを取得
 */

export function useGetBeverageRecordTranscription<TData = Awaited<ReturnType<typeof getBeverageRecordTranscription>>, TError = unknown>(
 residentUid: unknown,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBeverageRecordTranscription>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBeverageRecordTranscriptionQueryOptions(residentUid,uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 飲料記録の文字起こしを追記
 */
export const appendBeverageRecordTranscription = (
    residentUid: unknown,
    uid: string,
    transcriptionInputDto: TranscriptionInputDto,
 ) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/residents/${residentUid}/beverage-records/${uid}/transcription`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: transcriptionInputDto
    },
      );
    }
  


export const getAppendBeverageRecordTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appendBeverageRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appendBeverageRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext> => {
    
const mutationKey = ['appendBeverageRecordTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appendBeverageRecordTranscription>>, {residentUid: unknown;uid: string;data: TranscriptionInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  appendBeverageRecordTranscription(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppendBeverageRecordTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof appendBeverageRecordTranscription>>>
    export type AppendBeverageRecordTranscriptionMutationBody = TranscriptionInputDto
    export type AppendBeverageRecordTranscriptionMutationError = unknown

    /**
 * @summary 飲料記録の文字起こしを追記
 */
export const useAppendBeverageRecordTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appendBeverageRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof appendBeverageRecordTranscription>>,
        TError,
        {residentUid: unknown;uid: string;data: TranscriptionInputDto},
        TContext
      > => {

      const mutationOptions = getAppendBeverageRecordTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 飲料記録の文字起こしを置換
 */
export const updateBeverageRecordTranscription = (
    residentUid: unknown,
    uid: string,
    transcriptionInputDto: TranscriptionInputDto,
 ) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/residents/${residentUid}/beverage-records/${uid}/transcription`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: transcriptionInputDto
    },
      );
    }
  


export const getUpdateBeverageRecordTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBeverageRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBeverageRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext> => {
    
const mutationKey = ['updateBeverageRecordTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBeverageRecordTranscription>>, {residentUid: unknown;uid: string;data: TranscriptionInputDto}> = (props) => {
          const {residentUid,uid,data} = props ?? {};

          return  updateBeverageRecordTranscription(residentUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBeverageRecordTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof updateBeverageRecordTranscription>>>
    export type UpdateBeverageRecordTranscriptionMutationBody = TranscriptionInputDto
    export type UpdateBeverageRecordTranscriptionMutationError = unknown

    /**
 * @summary 飲料記録の文字起こしを置換
 */
export const useUpdateBeverageRecordTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBeverageRecordTranscription>>, TError,{residentUid: unknown;uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateBeverageRecordTranscription>>,
        TError,
        {residentUid: unknown;uid: string;data: TranscriptionInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateBeverageRecordTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 飲料記録の文字起こしを削除
 */
export const deleteBeverageRecordTranscription = (
    residentUid: unknown,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/residents/${residentUid}/beverage-records/${uid}/transcription`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteBeverageRecordTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBeverageRecordTranscription>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteBeverageRecordTranscription>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['deleteBeverageRecordTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBeverageRecordTranscription>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  deleteBeverageRecordTranscription(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBeverageRecordTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBeverageRecordTranscription>>>
    
    export type DeleteBeverageRecordTranscriptionMutationError = unknown

    /**
 * @summary 飲料記録の文字起こしを削除
 */
export const useDeleteBeverageRecordTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBeverageRecordTranscription>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteBeverageRecordTranscription>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteBeverageRecordTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 飲み物摂取記録から情報を抽出
 */
export const extractBeverageRecord = (
    residentUid: unknown,
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<BeverageRecordExtractedDto>(
      {url: `/residents/${residentUid}/beverage-records/${uid}/extract`, method: 'POST', signal
    },
      );
    }
  


export const getExtractBeverageRecordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractBeverageRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof extractBeverageRecord>>, TError,{residentUid: unknown;uid: string}, TContext> => {
    
const mutationKey = ['extractBeverageRecord'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof extractBeverageRecord>>, {residentUid: unknown;uid: string}> = (props) => {
          const {residentUid,uid} = props ?? {};

          return  extractBeverageRecord(residentUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExtractBeverageRecordMutationResult = NonNullable<Awaited<ReturnType<typeof extractBeverageRecord>>>
    
    export type ExtractBeverageRecordMutationError = unknown

    /**
 * @summary 飲み物摂取記録から情報を抽出
 */
export const useExtractBeverageRecord = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractBeverageRecord>>, TError,{residentUid: unknown;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof extractBeverageRecord>>,
        TError,
        {residentUid: unknown;uid: string},
        TContext
      > => {

      const mutationOptions = getExtractBeverageRecordMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アセスメント一覧を取得
 */
export const getAssessments = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<AssessmentListResponseDto>(
      {url: `/assessments`, method: 'GET', signal
    },
      );
    }
  

export const getGetAssessmentsQueryKey = () => {
    return [`/assessments`] as const;
    }

    
export const getGetAssessmentsQueryOptions = <TData = Awaited<ReturnType<typeof getAssessments>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessmentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessments>>> = ({ signal }) => getAssessments(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAssessmentsQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessments>>>
export type GetAssessmentsQueryError = unknown


export function useGetAssessments<TData = Awaited<ReturnType<typeof getAssessments>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssessments>>,
          TError,
          Awaited<ReturnType<typeof getAssessments>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAssessments<TData = Awaited<ReturnType<typeof getAssessments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssessments>>,
          TError,
          Awaited<ReturnType<typeof getAssessments>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAssessments<TData = Awaited<ReturnType<typeof getAssessments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessments>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary アセスメント一覧を取得
 */

export function useGetAssessments<TData = Awaited<ReturnType<typeof getAssessments>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessments>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAssessmentsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary アセスメントを作成
 */
export const createAssessment = (
    assessmentCreateInputDto: AssessmentCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AssessmentDto>(
      {url: `/assessments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: assessmentCreateInputDto, signal
    },
      );
    }
  


export const getCreateAssessmentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAssessment>>, TError,{data: AssessmentCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAssessment>>, TError,{data: AssessmentCreateInputDto}, TContext> => {
    
const mutationKey = ['createAssessment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAssessment>>, {data: AssessmentCreateInputDto}> = (props) => {
          const {data} = props ?? {};

          return  createAssessment(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAssessmentMutationResult = NonNullable<Awaited<ReturnType<typeof createAssessment>>>
    export type CreateAssessmentMutationBody = AssessmentCreateInputDto
    export type CreateAssessmentMutationError = unknown

    /**
 * @summary アセスメントを作成
 */
export const useCreateAssessment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAssessment>>, TError,{data: AssessmentCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createAssessment>>,
        TError,
        {data: AssessmentCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateAssessmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アセスメントの詳細を取得
 */
export const getAssessment = (
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AssessmentDto>(
      {url: `/assessments/${uid}`, method: 'GET', signal
    },
      );
    }
  

export const getGetAssessmentQueryKey = (uid: string,) => {
    return [`/assessments/${uid}`] as const;
    }

    
export const getGetAssessmentQueryOptions = <TData = Awaited<ReturnType<typeof getAssessment>>, TError = unknown>(uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessment>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssessmentQueryKey(uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssessment>>> = ({ signal }) => getAssessment(uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssessment>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAssessmentQueryResult = NonNullable<Awaited<ReturnType<typeof getAssessment>>>
export type GetAssessmentQueryError = unknown


export function useGetAssessment<TData = Awaited<ReturnType<typeof getAssessment>>, TError = unknown>(
 uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessment>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssessment>>,
          TError,
          Awaited<ReturnType<typeof getAssessment>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAssessment<TData = Awaited<ReturnType<typeof getAssessment>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessment>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssessment>>,
          TError,
          Awaited<ReturnType<typeof getAssessment>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAssessment<TData = Awaited<ReturnType<typeof getAssessment>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessment>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary アセスメントの詳細を取得
 */

export function useGetAssessment<TData = Awaited<ReturnType<typeof getAssessment>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssessment>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAssessmentQueryOptions(uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary アセスメントを更新
 */
export const updateAssessment = (
    uid: string,
    assessmentUpdateInputDto: AssessmentUpdateInputDto,
 ) => {
      
      
      return customInstance<AssessmentDto>(
      {url: `/assessments/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: assessmentUpdateInputDto
    },
      );
    }
  


export const getUpdateAssessmentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAssessment>>, TError,{uid: string;data: AssessmentUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAssessment>>, TError,{uid: string;data: AssessmentUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateAssessment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAssessment>>, {uid: string;data: AssessmentUpdateInputDto}> = (props) => {
          const {uid,data} = props ?? {};

          return  updateAssessment(uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAssessmentMutationResult = NonNullable<Awaited<ReturnType<typeof updateAssessment>>>
    export type UpdateAssessmentMutationBody = AssessmentUpdateInputDto
    export type UpdateAssessmentMutationError = unknown

    /**
 * @summary アセスメントを更新
 */
export const useUpdateAssessment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAssessment>>, TError,{uid: string;data: AssessmentUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateAssessment>>,
        TError,
        {uid: string;data: AssessmentUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateAssessmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アセスメントを削除
 */
export const deleteAssessment = (
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/assessments/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAssessmentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssessment>>, TError,{uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAssessment>>, TError,{uid: string}, TContext> => {
    
const mutationKey = ['deleteAssessment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAssessment>>, {uid: string}> = (props) => {
          const {uid} = props ?? {};

          return  deleteAssessment(uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAssessmentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAssessment>>>
    
    export type DeleteAssessmentMutationError = unknown

    /**
 * @summary アセスメントを削除
 */
export const useDeleteAssessment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssessment>>, TError,{uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteAssessment>>,
        TError,
        {uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteAssessmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アセスメントの文字起こしを取得
 */
export const getTranscription = (
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/assessments/${uid}/transcription`, method: 'GET', signal
    },
      );
    }
  

export const getGetTranscriptionQueryKey = (uid: string,) => {
    return [`/assessments/${uid}/transcription`] as const;
    }

    
export const getGetTranscriptionQueryOptions = <TData = Awaited<ReturnType<typeof getTranscription>>, TError = unknown>(uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTranscriptionQueryKey(uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTranscription>>> = ({ signal }) => getTranscription(uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTranscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof getTranscription>>>
export type GetTranscriptionQueryError = unknown


export function useGetTranscription<TData = Awaited<ReturnType<typeof getTranscription>>, TError = unknown>(
 uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTranscription>>,
          TError,
          Awaited<ReturnType<typeof getTranscription>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTranscription<TData = Awaited<ReturnType<typeof getTranscription>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTranscription>>,
          TError,
          Awaited<ReturnType<typeof getTranscription>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTranscription<TData = Awaited<ReturnType<typeof getTranscription>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary アセスメントの文字起こしを取得
 */

export function useGetTranscription<TData = Awaited<ReturnType<typeof getTranscription>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTranscription>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTranscriptionQueryOptions(uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary アセスメントの文字起こしを追記
 */
export const appendTranscription = (
    uid: string,
    transcriptionInputDto: TranscriptionInputDto,
 ) => {
      
      
      return customInstance<TranscriptionDto>(
      {url: `/assessments/${uid}/transcription`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: transcriptionInputDto
    },
      );
    }
  


export const getAppendTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appendTranscription>>, TError,{uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof appendTranscription>>, TError,{uid: string;data: TranscriptionInputDto}, TContext> => {
    
const mutationKey = ['appendTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof appendTranscription>>, {uid: string;data: TranscriptionInputDto}> = (props) => {
          const {uid,data} = props ?? {};

          return  appendTranscription(uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AppendTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof appendTranscription>>>
    export type AppendTranscriptionMutationBody = TranscriptionInputDto
    export type AppendTranscriptionMutationError = unknown

    /**
 * @summary アセスメントの文字起こしを追記
 */
export const useAppendTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof appendTranscription>>, TError,{uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof appendTranscription>>,
        TError,
        {uid: string;data: TranscriptionInputDto},
        TContext
      > => {

      const mutationOptions = getAppendTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary QAセッションの音声ファイルの文字起こしを更新する
 */
export const updateTranscription = (
    uid: string,
    transcriptionInputDto: TranscriptionInputDto,
 ) => {
      
      
      return customInstance<void>(
      {url: `/qa/sessions/${uid}/transcription`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: transcriptionInputDto
    },
      );
    }
  


export const getUpdateTranscriptionMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTranscription>>, TError,{uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateTranscription>>, TError,{uid: string;data: TranscriptionInputDto}, TContext> => {
    
const mutationKey = ['updateTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTranscription>>, {uid: string;data: TranscriptionInputDto}> = (props) => {
          const {uid,data} = props ?? {};

          return  updateTranscription(uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof updateTranscription>>>
    export type UpdateTranscriptionMutationBody = TranscriptionInputDto
    export type UpdateTranscriptionMutationError = void

    /**
 * @summary QAセッションの音声ファイルの文字起こしを更新する
 */
export const useUpdateTranscription = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTranscription>>, TError,{uid: string;data: TranscriptionInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateTranscription>>,
        TError,
        {uid: string;data: TranscriptionInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アセスメントの文字起こしを削除
 */
export const deleteTranscription = (
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/assessments/${uid}/transcription`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteTranscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTranscription>>, TError,{uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteTranscription>>, TError,{uid: string}, TContext> => {
    
const mutationKey = ['deleteTranscription'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTranscription>>, {uid: string}> = (props) => {
          const {uid} = props ?? {};

          return  deleteTranscription(uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTranscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTranscription>>>
    
    export type DeleteTranscriptionMutationError = unknown

    /**
 * @summary アセスメントの文字起こしを削除
 */
export const useDeleteTranscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTranscription>>, TError,{uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteTranscription>>,
        TError,
        {uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteTranscriptionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アセスメントの要約を作成
 */
export const summarizeAssessment = (
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/assessments/${uid}/summarize`, method: 'POST', signal
    },
      );
    }
  


export const getSummarizeAssessmentMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof summarizeAssessment>>, TError,{uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof summarizeAssessment>>, TError,{uid: string}, TContext> => {
    
const mutationKey = ['summarizeAssessment'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof summarizeAssessment>>, {uid: string}> = (props) => {
          const {uid} = props ?? {};

          return  summarizeAssessment(uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SummarizeAssessmentMutationResult = NonNullable<Awaited<ReturnType<typeof summarizeAssessment>>>
    
    export type SummarizeAssessmentMutationError = unknown

    /**
 * @summary アセスメントの要約を作成
 */
export const useSummarizeAssessment = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof summarizeAssessment>>, TError,{uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof summarizeAssessment>>,
        TError,
        {uid: string},
        TContext
      > => {

      const mutationOptions = getSummarizeAssessmentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary テナント内のアセスメント対象者一覧を取得
 */
export const getSubjects = (
    tenantUid?: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SubjectListResponseDto>(
      {url: `/tenants/${tenantUid}/subjects`, method: 'GET', signal
    },
      );
    }
  

export const getGetSubjectsQueryKey = (tenantUid?: string,) => {
    return [`/tenants/${tenantUid}/subjects`] as const;
    }

    
export const getGetSubjectsQueryOptions = <TData = Awaited<ReturnType<typeof getSubjects>>, TError = unknown>(tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjects>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectsQueryKey(tenantUid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubjects>>> = ({ signal }) => getSubjects(tenantUid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(tenantUid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubjects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSubjectsQueryResult = NonNullable<Awaited<ReturnType<typeof getSubjects>>>
export type GetSubjectsQueryError = unknown


export function useGetSubjects<TData = Awaited<ReturnType<typeof getSubjects>>, TError = unknown>(
 tenantUid: undefined |  string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubjects>>,
          TError,
          Awaited<ReturnType<typeof getSubjects>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubjects<TData = Awaited<ReturnType<typeof getSubjects>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubjects>>,
          TError,
          Awaited<ReturnType<typeof getSubjects>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubjects<TData = Awaited<ReturnType<typeof getSubjects>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjects>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary テナント内のアセスメント対象者一覧を取得
 */

export function useGetSubjects<TData = Awaited<ReturnType<typeof getSubjects>>, TError = unknown>(
 tenantUid?: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjects>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSubjectsQueryOptions(tenantUid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary テナントにアセスメント対象者を作成
 */
export const createSubject = (
    tenantUid: string,
    subjectCreateInputDto: SubjectCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SubjectDto>(
      {url: `/tenants/${tenantUid}/subjects`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: subjectCreateInputDto, signal
    },
      );
    }
  


export const getCreateSubjectMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSubject>>, TError,{tenantUid: string;data: SubjectCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSubject>>, TError,{tenantUid: string;data: SubjectCreateInputDto}, TContext> => {
    
const mutationKey = ['createSubject'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSubject>>, {tenantUid: string;data: SubjectCreateInputDto}> = (props) => {
          const {tenantUid,data} = props ?? {};

          return  createSubject(tenantUid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof createSubject>>>
    export type CreateSubjectMutationBody = SubjectCreateInputDto
    export type CreateSubjectMutationError = unknown

    /**
 * @summary テナントにアセスメント対象者を作成
 */
export const useCreateSubject = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSubject>>, TError,{tenantUid: string;data: SubjectCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createSubject>>,
        TError,
        {tenantUid: string;data: SubjectCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateSubjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アセスメント対象者の詳細を取得
 */
export const getSubject = (
    tenantUid: string,
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SubjectDto>(
      {url: `/tenants/${tenantUid}/subjects/${uid}`, method: 'GET', signal
    },
      );
    }
  

export const getGetSubjectQueryKey = (tenantUid: string,
    uid: string,) => {
    return [`/tenants/${tenantUid}/subjects/${uid}`] as const;
    }

    
export const getGetSubjectQueryOptions = <TData = Awaited<ReturnType<typeof getSubject>>, TError = unknown>(tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectQueryKey(tenantUid,uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubject>>> = ({ signal }) => getSubject(tenantUid,uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(tenantUid && uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSubjectQueryResult = NonNullable<Awaited<ReturnType<typeof getSubject>>>
export type GetSubjectQueryError = unknown


export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = unknown>(
 tenantUid: string,
    uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubject>>,
          TError,
          Awaited<ReturnType<typeof getSubject>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = unknown>(
 tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubject>>,
          TError,
          Awaited<ReturnType<typeof getSubject>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = unknown>(
 tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary アセスメント対象者の詳細を取得
 */

export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = unknown>(
 tenantUid: string,
    uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSubjectQueryOptions(tenantUid,uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary アセスメント対象者を更新
 */
export const updateSubject = (
    tenantUid: string,
    uid: string,
    subjectUpdateInputDto: SubjectUpdateInputDto,
 ) => {
      
      
      return customInstance<SubjectDto>(
      {url: `/tenants/${tenantUid}/subjects/${uid}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: subjectUpdateInputDto
    },
      );
    }
  


export const getUpdateSubjectMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSubject>>, TError,{tenantUid: string;uid: string;data: SubjectUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateSubject>>, TError,{tenantUid: string;uid: string;data: SubjectUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateSubject'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSubject>>, {tenantUid: string;uid: string;data: SubjectUpdateInputDto}> = (props) => {
          const {tenantUid,uid,data} = props ?? {};

          return  updateSubject(tenantUid,uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof updateSubject>>>
    export type UpdateSubjectMutationBody = SubjectUpdateInputDto
    export type UpdateSubjectMutationError = unknown

    /**
 * @summary アセスメント対象者を更新
 */
export const useUpdateSubject = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSubject>>, TError,{tenantUid: string;uid: string;data: SubjectUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateSubject>>,
        TError,
        {tenantUid: string;uid: string;data: SubjectUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateSubjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アセスメント対象者を削除
 */
export const deleteSubject = (
    tenantUid: string,
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/tenants/${tenantUid}/subjects/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteSubjectMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSubject>>, TError,{tenantUid: string;uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteSubject>>, TError,{tenantUid: string;uid: string}, TContext> => {
    
const mutationKey = ['deleteSubject'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSubject>>, {tenantUid: string;uid: string}> = (props) => {
          const {tenantUid,uid} = props ?? {};

          return  deleteSubject(tenantUid,uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSubject>>>
    
    export type DeleteSubjectMutationError = unknown

    /**
 * @summary アセスメント対象者を削除
 */
export const useDeleteSubject = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSubject>>, TError,{tenantUid: string;uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteSubject>>,
        TError,
        {tenantUid: string;uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteSubjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 新しいスレッドを作成
 */
export const createThread = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<ThreadCreateOutputDto>(
      {url: `/chats`, method: 'POST', signal
    },
      );
    }
  


export const getCreateThreadMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createThread>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createThread>>, TError,void, TContext> => {
    
const mutationKey = ['createThread'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createThread>>, void> = () => {
          

          return  createThread()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateThreadMutationResult = NonNullable<Awaited<ReturnType<typeof createThread>>>
    
    export type CreateThreadMutationError = unknown

    /**
 * @summary 新しいスレッドを作成
 */
export const useCreateThread = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createThread>>, TError,void, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createThread>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreateThreadMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary スレッド一覧を取得
 */
export const getThreads = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<ThreadListOutputDto>(
      {url: `/chats`, method: 'GET', signal
    },
      );
    }
  

export const getGetThreadsQueryKey = () => {
    return [`/chats`] as const;
    }

    
export const getGetThreadsQueryOptions = <TData = Awaited<ReturnType<typeof getThreads>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getThreads>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetThreadsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getThreads>>> = ({ signal }) => getThreads(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getThreads>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetThreadsQueryResult = NonNullable<Awaited<ReturnType<typeof getThreads>>>
export type GetThreadsQueryError = unknown


export function useGetThreads<TData = Awaited<ReturnType<typeof getThreads>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getThreads>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getThreads>>,
          TError,
          Awaited<ReturnType<typeof getThreads>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetThreads<TData = Awaited<ReturnType<typeof getThreads>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getThreads>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getThreads>>,
          TError,
          Awaited<ReturnType<typeof getThreads>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetThreads<TData = Awaited<ReturnType<typeof getThreads>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getThreads>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary スレッド一覧を取得
 */

export function useGetThreads<TData = Awaited<ReturnType<typeof getThreads>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getThreads>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetThreadsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary 特定のスレッドを取得
 */
export const getThread = (
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ThreadOutputDto>(
      {url: `/chats/${uid}`, method: 'GET', signal
    },
      );
    }
  

export const getGetThreadQueryKey = (uid: string,) => {
    return [`/chats/${uid}`] as const;
    }

    
export const getGetThreadQueryOptions = <TData = Awaited<ReturnType<typeof getThread>>, TError = unknown>(uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getThread>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetThreadQueryKey(uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getThread>>> = ({ signal }) => getThread(uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getThread>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetThreadQueryResult = NonNullable<Awaited<ReturnType<typeof getThread>>>
export type GetThreadQueryError = unknown


export function useGetThread<TData = Awaited<ReturnType<typeof getThread>>, TError = unknown>(
 uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getThread>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getThread>>,
          TError,
          Awaited<ReturnType<typeof getThread>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetThread<TData = Awaited<ReturnType<typeof getThread>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getThread>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getThread>>,
          TError,
          Awaited<ReturnType<typeof getThread>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetThread<TData = Awaited<ReturnType<typeof getThread>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getThread>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 特定のスレッドを取得
 */

export function useGetThread<TData = Awaited<ReturnType<typeof getThread>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getThread>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetThreadQueryOptions(uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary スレッドを更新
 */
export const updateThread = (
    uid: string,
    threadUpdateInputDto: ThreadUpdateInputDto,
 ) => {
      
      
      return customInstance<void>(
      {url: `/chats/${uid}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: threadUpdateInputDto
    },
      );
    }
  


export const getUpdateThreadMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateThread>>, TError,{uid: string;data: ThreadUpdateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateThread>>, TError,{uid: string;data: ThreadUpdateInputDto}, TContext> => {
    
const mutationKey = ['updateThread'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateThread>>, {uid: string;data: ThreadUpdateInputDto}> = (props) => {
          const {uid,data} = props ?? {};

          return  updateThread(uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateThreadMutationResult = NonNullable<Awaited<ReturnType<typeof updateThread>>>
    export type UpdateThreadMutationBody = ThreadUpdateInputDto
    export type UpdateThreadMutationError = unknown

    /**
 * @summary スレッドを更新
 */
export const useUpdateThread = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateThread>>, TError,{uid: string;data: ThreadUpdateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateThread>>,
        TError,
        {uid: string;data: ThreadUpdateInputDto},
        TContext
      > => {

      const mutationOptions = getUpdateThreadMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary スレッドを削除
 */
export const deleteThread = (
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/chats/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteThreadMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteThread>>, TError,{uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteThread>>, TError,{uid: string}, TContext> => {
    
const mutationKey = ['deleteThread'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteThread>>, {uid: string}> = (props) => {
          const {uid} = props ?? {};

          return  deleteThread(uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteThreadMutationResult = NonNullable<Awaited<ReturnType<typeof deleteThread>>>
    
    export type DeleteThreadMutationError = unknown

    /**
 * @summary スレッドを削除
 */
export const useDeleteThread = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteThread>>, TError,{uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteThread>>,
        TError,
        {uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteThreadMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary メッセージを作成
 */
export const createMessage = (
    uid: string,
    messageCreateInputDto: MessageCreateInputDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/chats/${uid}/messages`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: messageCreateInputDto, signal
    },
      );
    }
  


export const getCreateMessageMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMessage>>, TError,{uid: string;data: MessageCreateInputDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createMessage>>, TError,{uid: string;data: MessageCreateInputDto}, TContext> => {
    
const mutationKey = ['createMessage'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createMessage>>, {uid: string;data: MessageCreateInputDto}> = (props) => {
          const {uid,data} = props ?? {};

          return  createMessage(uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateMessageMutationResult = NonNullable<Awaited<ReturnType<typeof createMessage>>>
    export type CreateMessageMutationBody = MessageCreateInputDto
    export type CreateMessageMutationError = unknown

    /**
 * @summary メッセージを作成
 */
export const useCreateMessage = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMessage>>, TError,{uid: string;data: MessageCreateInputDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createMessage>>,
        TError,
        {uid: string;data: MessageCreateInputDto},
        TContext
      > => {

      const mutationOptions = getCreateMessageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary QAセッションを作成する
 */
export const createQaSession = (
    createQaSessionDto: CreateQaSessionDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<QaSessionOutputDto>(
      {url: `/qa/sessions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createQaSessionDto, signal
    },
      );
    }
  


export const getCreateQaSessionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createQaSession>>, TError,{data: CreateQaSessionDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createQaSession>>, TError,{data: CreateQaSessionDto}, TContext> => {
    
const mutationKey = ['createQaSession'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createQaSession>>, {data: CreateQaSessionDto}> = (props) => {
          const {data} = props ?? {};

          return  createQaSession(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateQaSessionMutationResult = NonNullable<Awaited<ReturnType<typeof createQaSession>>>
    export type CreateQaSessionMutationBody = CreateQaSessionDto
    export type CreateQaSessionMutationError = unknown

    /**
 * @summary QAセッションを作成する
 */
export const useCreateQaSession = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createQaSession>>, TError,{data: CreateQaSessionDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof createQaSession>>,
        TError,
        {data: CreateQaSessionDto},
        TContext
      > => {

      const mutationOptions = getCreateQaSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ユーザーに紐づくQAセッション一覧を取得する
 */
export const findQaSessionsByUser = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<QaSessionListOutputDto>(
      {url: `/qa/sessions`, method: 'GET', signal
    },
      );
    }
  

export const getFindQaSessionsByUserQueryKey = () => {
    return [`/qa/sessions`] as const;
    }

    
export const getFindQaSessionsByUserQueryOptions = <TData = Awaited<ReturnType<typeof findQaSessionsByUser>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findQaSessionsByUser>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindQaSessionsByUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findQaSessionsByUser>>> = ({ signal }) => findQaSessionsByUser(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findQaSessionsByUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindQaSessionsByUserQueryResult = NonNullable<Awaited<ReturnType<typeof findQaSessionsByUser>>>
export type FindQaSessionsByUserQueryError = unknown


export function useFindQaSessionsByUser<TData = Awaited<ReturnType<typeof findQaSessionsByUser>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof findQaSessionsByUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findQaSessionsByUser>>,
          TError,
          Awaited<ReturnType<typeof findQaSessionsByUser>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindQaSessionsByUser<TData = Awaited<ReturnType<typeof findQaSessionsByUser>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findQaSessionsByUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findQaSessionsByUser>>,
          TError,
          Awaited<ReturnType<typeof findQaSessionsByUser>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindQaSessionsByUser<TData = Awaited<ReturnType<typeof findQaSessionsByUser>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findQaSessionsByUser>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ユーザーに紐づくQAセッション一覧を取得する
 */

export function useFindQaSessionsByUser<TData = Awaited<ReturnType<typeof findQaSessionsByUser>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findQaSessionsByUser>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFindQaSessionsByUserQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary QAセッションを取得する
 */
export const findQaSession = (
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<QaSessionOutputDto>(
      {url: `/qa/sessions/${uid}`, method: 'GET', signal
    },
      );
    }
  

export const getFindQaSessionQueryKey = (uid: string,) => {
    return [`/qa/sessions/${uid}`] as const;
    }

    
export const getFindQaSessionQueryOptions = <TData = Awaited<ReturnType<typeof findQaSession>>, TError = void>(uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findQaSession>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindQaSessionQueryKey(uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findQaSession>>> = ({ signal }) => findQaSession(uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findQaSession>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindQaSessionQueryResult = NonNullable<Awaited<ReturnType<typeof findQaSession>>>
export type FindQaSessionQueryError = void


export function useFindQaSession<TData = Awaited<ReturnType<typeof findQaSession>>, TError = void>(
 uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof findQaSession>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findQaSession>>,
          TError,
          Awaited<ReturnType<typeof findQaSession>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindQaSession<TData = Awaited<ReturnType<typeof findQaSession>>, TError = void>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findQaSession>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findQaSession>>,
          TError,
          Awaited<ReturnType<typeof findQaSession>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindQaSession<TData = Awaited<ReturnType<typeof findQaSession>>, TError = void>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findQaSession>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary QAセッションを取得する
 */

export function useFindQaSession<TData = Awaited<ReturnType<typeof findQaSession>>, TError = void>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findQaSession>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFindQaSessionQueryOptions(uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary QAセッションを削除する
 */
export const deleteQaSession = (
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/qa/sessions/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteQaSessionMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteQaSession>>, TError,{uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteQaSession>>, TError,{uid: string}, TContext> => {
    
const mutationKey = ['deleteQaSession'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteQaSession>>, {uid: string}> = (props) => {
          const {uid} = props ?? {};

          return  deleteQaSession(uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteQaSessionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteQaSession>>>
    
    export type DeleteQaSessionMutationError = void

    /**
 * @summary QAセッションを削除する
 */
export const useDeleteQaSession = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteQaSession>>, TError,{uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteQaSession>>,
        TError,
        {uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteQaSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary QAセッションに質問回答を追加する
 */
export const addQuestionAnswer = (
    createQuestionAnswerDto: CreateQuestionAnswerDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<QuestionAnswerOutputDto>(
      {url: `/qa/question-answers`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createQuestionAnswerDto, signal
    },
      );
    }
  


export const getAddQuestionAnswerMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addQuestionAnswer>>, TError,{data: CreateQuestionAnswerDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addQuestionAnswer>>, TError,{data: CreateQuestionAnswerDto}, TContext> => {
    
const mutationKey = ['addQuestionAnswer'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addQuestionAnswer>>, {data: CreateQuestionAnswerDto}> = (props) => {
          const {data} = props ?? {};

          return  addQuestionAnswer(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddQuestionAnswerMutationResult = NonNullable<Awaited<ReturnType<typeof addQuestionAnswer>>>
    export type AddQuestionAnswerMutationBody = CreateQuestionAnswerDto
    export type AddQuestionAnswerMutationError = unknown

    /**
 * @summary QAセッションに質問回答を追加する
 */
export const useAddQuestionAnswer = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addQuestionAnswer>>, TError,{data: CreateQuestionAnswerDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof addQuestionAnswer>>,
        TError,
        {data: CreateQuestionAnswerDto},
        TContext
      > => {

      const mutationOptions = getAddQuestionAnswerMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 質問回答を更新する
 */
export const updateQuestionAnswer = (
    uid: string,
    updateQuestionAnswerDto: UpdateQuestionAnswerDto,
 ) => {
      
      
      return customInstance<QuestionAnswerOutputDto>(
      {url: `/qa/question-answers/${uid}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateQuestionAnswerDto
    },
      );
    }
  


export const getUpdateQuestionAnswerMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateQuestionAnswer>>, TError,{uid: string;data: UpdateQuestionAnswerDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateQuestionAnswer>>, TError,{uid: string;data: UpdateQuestionAnswerDto}, TContext> => {
    
const mutationKey = ['updateQuestionAnswer'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateQuestionAnswer>>, {uid: string;data: UpdateQuestionAnswerDto}> = (props) => {
          const {uid,data} = props ?? {};

          return  updateQuestionAnswer(uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateQuestionAnswerMutationResult = NonNullable<Awaited<ReturnType<typeof updateQuestionAnswer>>>
    export type UpdateQuestionAnswerMutationBody = UpdateQuestionAnswerDto
    export type UpdateQuestionAnswerMutationError = void

    /**
 * @summary 質問回答を更新する
 */
export const useUpdateQuestionAnswer = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateQuestionAnswer>>, TError,{uid: string;data: UpdateQuestionAnswerDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof updateQuestionAnswer>>,
        TError,
        {uid: string;data: UpdateQuestionAnswerDto},
        TContext
      > => {

      const mutationOptions = getUpdateQuestionAnswerMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 質問回答を削除する
 */
export const deleteQuestionAnswer = (
    uid: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/qa/question-answers/${uid}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteQuestionAnswerMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteQuestionAnswer>>, TError,{uid: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteQuestionAnswer>>, TError,{uid: string}, TContext> => {
    
const mutationKey = ['deleteQuestionAnswer'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteQuestionAnswer>>, {uid: string}> = (props) => {
          const {uid} = props ?? {};

          return  deleteQuestionAnswer(uid,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteQuestionAnswerMutationResult = NonNullable<Awaited<ReturnType<typeof deleteQuestionAnswer>>>
    
    export type DeleteQuestionAnswerMutationError = void

    /**
 * @summary 質問回答を削除する
 */
export const useDeleteQuestionAnswer = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteQuestionAnswer>>, TError,{uid: string}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteQuestionAnswer>>,
        TError,
        {uid: string},
        TContext
      > => {

      const mutationOptions = getDeleteQuestionAnswerMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary QAセッションに紐づく質問回答を一括更新（置き換え）する
 */
export const upsertQuestionAnswers = (
    uid: string,
    upsertQuestionAnswersDto: UpsertQuestionAnswersDto,
 signal?: AbortSignal
) => {
      
      
      return customInstance<QaSessionOutputDto>(
      {url: `/qa/sessions/${uid}/upsert-question-answers`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: upsertQuestionAnswersDto, signal
    },
      );
    }
  


export const getUpsertQuestionAnswersMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof upsertQuestionAnswers>>, TError,{uid: string;data: UpsertQuestionAnswersDto}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof upsertQuestionAnswers>>, TError,{uid: string;data: UpsertQuestionAnswersDto}, TContext> => {
    
const mutationKey = ['upsertQuestionAnswers'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof upsertQuestionAnswers>>, {uid: string;data: UpsertQuestionAnswersDto}> = (props) => {
          const {uid,data} = props ?? {};

          return  upsertQuestionAnswers(uid,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpsertQuestionAnswersMutationResult = NonNullable<Awaited<ReturnType<typeof upsertQuestionAnswers>>>
    export type UpsertQuestionAnswersMutationBody = UpsertQuestionAnswersDto
    export type UpsertQuestionAnswersMutationError = void

    /**
 * @summary QAセッションに紐づく質問回答を一括更新（置き換え）する
 */
export const useUpsertQuestionAnswers = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof upsertQuestionAnswers>>, TError,{uid: string;data: UpsertQuestionAnswersDto}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof upsertQuestionAnswers>>,
        TError,
        {uid: string;data: UpsertQuestionAnswersDto},
        TContext
      > => {

      const mutationOptions = getUpsertQuestionAnswersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 文字起こしから質問と回答のペアを抽出する
 */
export const extractQaPairsFromTranscription = (
    uid: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ExtractQaPairsOutputDto>(
      {url: `/qa/sessions/${uid}/extract`, method: 'GET', signal
    },
      );
    }
  

export const getExtractQaPairsFromTranscriptionQueryKey = (uid: string,) => {
    return [`/qa/sessions/${uid}/extract`] as const;
    }

    
export const getExtractQaPairsFromTranscriptionQueryOptions = <TData = Awaited<ReturnType<typeof extractQaPairsFromTranscription>>, TError = unknown>(uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof extractQaPairsFromTranscription>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getExtractQaPairsFromTranscriptionQueryKey(uid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof extractQaPairsFromTranscription>>> = ({ signal }) => extractQaPairsFromTranscription(uid, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(uid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof extractQaPairsFromTranscription>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ExtractQaPairsFromTranscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof extractQaPairsFromTranscription>>>
export type ExtractQaPairsFromTranscriptionQueryError = unknown


export function useExtractQaPairsFromTranscription<TData = Awaited<ReturnType<typeof extractQaPairsFromTranscription>>, TError = unknown>(
 uid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof extractQaPairsFromTranscription>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof extractQaPairsFromTranscription>>,
          TError,
          Awaited<ReturnType<typeof extractQaPairsFromTranscription>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExtractQaPairsFromTranscription<TData = Awaited<ReturnType<typeof extractQaPairsFromTranscription>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof extractQaPairsFromTranscription>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof extractQaPairsFromTranscription>>,
          TError,
          Awaited<ReturnType<typeof extractQaPairsFromTranscription>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExtractQaPairsFromTranscription<TData = Awaited<ReturnType<typeof extractQaPairsFromTranscription>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof extractQaPairsFromTranscription>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary 文字起こしから質問と回答のペアを抽出する
 */

export function useExtractQaPairsFromTranscription<TData = Awaited<ReturnType<typeof extractQaPairsFromTranscription>>, TError = unknown>(
 uid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof extractQaPairsFromTranscription>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getExtractQaPairsFromTranscriptionQueryOptions(uid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




